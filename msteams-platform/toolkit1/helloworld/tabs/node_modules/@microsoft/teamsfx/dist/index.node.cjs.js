'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var jwt_decode = require('jwt-decode');
var msalNode = require('@azure/msal-node');
var crypto = require('crypto');
var microsoftGraphClient = require('@microsoft/microsoft-graph-client');
var identity = require('@azure/identity');
var botbuilder = require('botbuilder');
var botbuilderDialogs = require('botbuilder-dialogs');
var uuid = require('uuid');
var axios = require('axios');
var https = require('https');
var path = require('path');
var fs = require('fs');
var adaptivecardsTools = require('@microsoft/adaptivecards-tools');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var jwt_decode__default = /*#__PURE__*/_interopDefaultLegacy(jwt_decode);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Error code to trace the error types.
 */
exports.ErrorCode = void 0;
(function (ErrorCode) {
    /**
     * Invalid parameter error.
     */
    ErrorCode["InvalidParameter"] = "InvalidParameter";
    /**
     * Invalid configuration error.
     */
    ErrorCode["InvalidConfiguration"] = "InvalidConfiguration";
    /**
     * Invalid certificate error.
     */
    ErrorCode["InvalidCertificate"] = "InvalidCertificate";
    /**
     * Internal error.
     */
    ErrorCode["InternalError"] = "InternalError";
    /**
     * Channel is not supported error.
     */
    ErrorCode["ChannelNotSupported"] = "ChannelNotSupported";
    /**
     * Runtime is not supported error.
     */
    ErrorCode["RuntimeNotSupported"] = "RuntimeNotSupported";
    /**
     * User failed to finish the AAD consent flow failed.
     */
    ErrorCode["ConsentFailed"] = "ConsentFailed";
    /**
     * The user or administrator has not consented to use the application error.
     */
    ErrorCode["UiRequiredError"] = "UiRequiredError";
    /**
     * Token is not within its valid time range error.
     */
    ErrorCode["TokenExpiredError"] = "TokenExpiredError";
    /**
     * Call service (AAD or simple authentication server) failed.
     */
    ErrorCode["ServiceError"] = "ServiceError";
    /**
     * Operation failed.
     */
    ErrorCode["FailedOperation"] = "FailedOperation";
    /**
     * Invalid response error.
     */
    ErrorCode["InvalidResponse"] = "InvalidResponse";
    /**
     * Identity type error.
     */
    ErrorCode["IdentityTypeNotSupported"] = "IdentityTypeNotSupported";
    /**
     * Authentication info already exists error.
     */
    ErrorCode["AuthorizationInfoAlreadyExists"] = "AuthorizationInfoAlreadyExists";
})(exports.ErrorCode || (exports.ErrorCode = {}));
/**
 * @internal
 */
class ErrorMessage {
}
// InvalidConfiguration Error
ErrorMessage.InvalidConfiguration = "{0} in configuration is invalid: {1}.";
ErrorMessage.ConfigurationNotExists = "Configuration does not exist. {0}";
ErrorMessage.ResourceConfigurationNotExists = "{0} resource configuration does not exist.";
ErrorMessage.MissingResourceConfiguration = "Missing resource configuration with type: {0}, name: {1}.";
ErrorMessage.AuthenticationConfigurationNotExists = "Authentication configuration does not exist.";
// RuntimeNotSupported Error
ErrorMessage.BrowserRuntimeNotSupported = "{0} is not supported in browser.";
ErrorMessage.NodejsRuntimeNotSupported = "{0} is not supported in Node.";
// Internal Error
ErrorMessage.FailToAcquireTokenOnBehalfOfUser = "Failed to acquire access token on behalf of user: {0}";
// ChannelNotSupported Error
ErrorMessage.OnlyMSTeamsChannelSupported = "{0} is only supported in MS Teams Channel";
// IdentityTypeNotSupported Error
ErrorMessage.IdentityTypeNotSupported = "{0} identity is not supported in {1}";
// AuthorizationInfoError
ErrorMessage.AuthorizationHeaderAlreadyExists = "Authorization header already exists!";
ErrorMessage.BasicCredentialAlreadyExists = "Basic credential already exists!";
// InvalidParameter Error
ErrorMessage.EmptyParameter = "Parameter {0} is empty";
ErrorMessage.DuplicateHttpsOptionProperty = "Axios HTTPS agent already defined value for property {0}";
ErrorMessage.DuplicateApiKeyInHeader = "The request already defined api key in request header with name {0}.";
ErrorMessage.DuplicateApiKeyInQueryParam = "The request already defined api key in query parameter with name {0}.";
/**
 * Error class with code and message thrown by the SDK.
 */
class ErrorWithCode extends Error {
    /**
     * Constructor of ErrorWithCode.
     *
     * @param {string} message - error message.
     * @param {ErrorCode} code - error code.
     */
    constructor(message, code) {
        if (!code) {
            super(message);
            return this;
        }
        super(message);
        Object.setPrototypeOf(this, ErrorWithCode.prototype);
        this.name = `${new.target.name}.${code}`;
        this.code = code;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Log level.
 */
exports.LogLevel = void 0;
(function (LogLevel) {
    /**
     * Show verbose, information, warning and error message.
     */
    LogLevel[LogLevel["Verbose"] = 0] = "Verbose";
    /**
     * Show information, warning and error message.
     */
    LogLevel[LogLevel["Info"] = 1] = "Info";
    /**
     * Show warning and error message.
     */
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    /**
     * Show error message.
     */
    LogLevel[LogLevel["Error"] = 3] = "Error";
})(exports.LogLevel || (exports.LogLevel = {}));
/**
 * Update log level helper.
 *
 * @param { LogLevel } level - log level in configuration
 */
function setLogLevel(level) {
    internalLogger.level = level;
}
/**
 * Get log level.
 *
 * @returns Log level
 */
function getLogLevel() {
    return internalLogger.level;
}
class InternalLogger {
    constructor(name, logLevel) {
        this.level = undefined;
        this.defaultLogger = {
            verbose: console.debug,
            info: console.info,
            warn: console.warn,
            error: console.error,
        };
        this.name = name;
        this.level = logLevel;
    }
    error(message) {
        this.log(exports.LogLevel.Error, (x) => x.error, message);
    }
    warn(message) {
        this.log(exports.LogLevel.Warn, (x) => x.warn, message);
    }
    info(message) {
        this.log(exports.LogLevel.Info, (x) => x.info, message);
    }
    verbose(message) {
        this.log(exports.LogLevel.Verbose, (x) => x.verbose, message);
    }
    log(logLevel, logFunction, message) {
        if (message.trim() === "") {
            return;
        }
        const timestamp = new Date().toUTCString();
        let logHeader;
        if (this.name) {
            logHeader = `[${timestamp}] : @microsoft/teamsfx - ${this.name} : ${exports.LogLevel[logLevel]} - `;
        }
        else {
            logHeader = `[${timestamp}] : @microsoft/teamsfx : ${exports.LogLevel[logLevel]} - `;
        }
        const logMessage = `${logHeader}${message}`;
        if (this.level !== undefined && this.level <= logLevel) {
            if (this.customLogger) {
                logFunction(this.customLogger)(logMessage);
            }
            else if (this.customLogFunction) {
                this.customLogFunction(logLevel, logMessage);
            }
            else {
                logFunction(this.defaultLogger)(logMessage);
            }
        }
    }
}
/**
 * Logger instance used internally
 *
 * @internal
 */
const internalLogger = new InternalLogger();
/**
 * Set custom logger. Use the output functions if it's set. Priority is higher than setLogFunction.
 *
 * @param {Logger} logger - custom logger. If it's undefined, custom logger will be cleared.
 *
 * @example
 * ```typescript
 * setLogger({
 *   verbose: console.debug,
 *   info: console.info,
 *   warn: console.warn,
 *   error: console.error,
 * });
 * ```
 */
function setLogger(logger) {
    internalLogger.customLogger = logger;
}
/**
 * Set custom log function. Use the function if it's set. Priority is lower than setLogger.
 *
 * @param {LogFunction} logFunction - custom log function. If it's undefined, custom log function will be cleared.
 *
 * @example
 * ```typescript
 * setLogFunction((level: LogLevel, message: string) => {
 *   if (level === LogLevel.Error) {
 *     console.log(message);
 *   }
 * });
 * ```
 */
function setLogFunction(logFunction) {
    internalLogger.customLogFunction = logFunction;
}

// Copyright (c) Microsoft Corporation.
/**
 * Parse jwt token payload
 *
 * @param token
 *
 * @returns Payload object
 *
 * @internal
 */
function parseJwt(token) {
    try {
        const tokenObj = jwt_decode__default["default"](token);
        if (!tokenObj || !tokenObj.exp) {
            throw new ErrorWithCode("Decoded token is null or exp claim does not exists.", exports.ErrorCode.InternalError);
        }
        return tokenObj;
    }
    catch (err) {
        const errorMsg = "Parse jwt token failed in node env with error: " + err.message;
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, exports.ErrorCode.InternalError);
    }
}
/**
 * @internal
 */
function getUserInfoFromSsoToken(ssoToken) {
    if (!ssoToken) {
        const errorMsg = "SSO token is undefined.";
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidParameter);
    }
    const tokenObject = parseJwt(ssoToken);
    const userInfo = {
        displayName: tokenObject.name,
        objectId: tokenObject.oid,
        preferredUserName: "",
    };
    if (tokenObject.ver === "2.0") {
        userInfo.preferredUserName = tokenObject.preferred_username;
    }
    else if (tokenObject.ver === "1.0") {
        userInfo.preferredUserName = tokenObject.upn;
    }
    return userInfo;
}
/**
 * Format string template with replacements
 *
 * ```typescript
 * const template = "{0} and {1} are fruit. {0} is my favorite one."
 * const formattedStr = formatString(template, "apple", "pear"); // formattedStr: "apple and pear are fruit. apple is my favorite one."
 * ```
 *
 * @param str string template
 * @param replacements replacement string array
 * @returns Formatted string
 *
 * @internal
 */
function formatString(str, ...replacements) {
    const args = replacements;
    return str.replace(/{(\d+)}/g, function (match, number) {
        return typeof args[number] != "undefined" ? args[number] : match;
    });
}
/**
 * @internal
 */
function validateScopesType(value) {
    // string
    if (typeof value === "string" || value instanceof String) {
        return;
    }
    // empty array
    if (Array.isArray(value) && value.length === 0) {
        return;
    }
    // string array
    if (Array.isArray(value) && value.length > 0 && value.every((item) => typeof item === "string")) {
        return;
    }
    const errorMsg = "The type of scopes is not valid, it must be string or string array";
    internalLogger.error(errorMsg);
    throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidParameter);
}
/**
 * @internal
 */
function getScopesArray(scopes) {
    const scopesArray = typeof scopes === "string" ? scopes.split(" ") : scopes;
    return scopesArray.filter((x) => x !== null && x !== "");
}
/**
 * @internal
 */
function getAuthority(authorityHost, tenantId) {
    const normalizedAuthorityHost = authorityHost.replace(/\/+$/g, "");
    return normalizedAuthorityHost + "/" + tenantId;
}

/**
 * @internal
 */
function createConfidentialClientApplication(authentication) {
    const authority = getAuthority(authentication.authorityHost, authentication.tenantId);
    const clientCertificate = parseCertificate(authentication.certificateContent);
    const auth = {
        clientId: authentication.clientId,
        authority: authority,
    };
    if (clientCertificate) {
        auth.clientCertificate = clientCertificate;
    }
    else {
        auth.clientSecret = authentication.clientSecret;
    }
    return new msalNode.ConfidentialClientApplication({
        auth,
    });
}
/**
 * @internal
 */
function parseCertificate(certificateContent) {
    if (!certificateContent) {
        return undefined;
    }
    const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/;
    const match = certificatePattern.exec(certificateContent);
    if (!match) {
        const errorMsg = "The certificate content does not contain a PEM-encoded certificate.";
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidCertificate);
    }
    const thumbprint = crypto.createHash("sha1")
        .update(Buffer.from(match[3], "base64"))
        .digest("hex")
        .toUpperCase();
    return {
        thumbprint: thumbprint,
        privateKey: certificateContent,
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Represent Microsoft 365 tenant identity, and it is usually used when user is not involved like time-triggered automation job.
 *
 * @example
 * ```typescript
 * loadConfiguration(); // load configuration from environment variables
 * const credential = new AppCredential();
 * ```
 *
 * @remarks
 * Only works in in server side.
 */
class AppCredential {
    /**
     * Constructor of AppCredential.
     *
     * @remarks
     * Only works in in server side.
     *
     * @param {AuthenticationConfiguration} authConfig - The authentication configuration. Use environment variables if not provided.
     *
     * @throws {@link ErrorCode|InvalidConfiguration} when client id, client secret or tenant id is not found in config.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    constructor(authConfig) {
        internalLogger.info("Create M365 tenant credential");
        const config = this.loadAndValidateConfig(authConfig);
        this.msalClient = createConfidentialClientApplication(config);
    }
    /**
     * Get access token for credential.
     *
     * @example
     * ```typescript
     * await credential.getToken(["User.Read.All"]) // Get Graph access token for single scope using string array
     * await credential.getToken("User.Read.All") // Get Graph access token for single scope using string
     * await credential.getToken(["User.Read.All", "Calendars.Read"]) // Get Graph access token for multiple scopes using string array
     * await credential.getToken("User.Read.All Calendars.Read") // Get Graph access token for multiple scopes using space-separated string
     * await credential.getToken("https://graph.microsoft.com/User.Read.All") // Get Graph access token with full resource URI
     * await credential.getToken(["https://outlook.office.com/Mail.Read"]) // Get Outlook access token
     * ```
     *
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     * @param {GetTokenOptions} options - The options used to configure any requests this TokenCredential implementation might make.
     *
     * @throws {@link ErrorCode|ServiceError} when get access token with authentication error.
     * @throws {@link ErrorCode|InternalError} when get access token with unknown error.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     *
     * @returns Access token with expected scopes.
     * Throw error if get access token failed.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let accessToken;
            validateScopesType(scopes);
            const scopesStr = typeof scopes === "string" ? scopes : scopes.join(" ");
            internalLogger.info("Get access token with scopes: " + scopesStr);
            try {
                const scopesArray = getScopesArray(scopes);
                const authenticationResult = yield this.msalClient.acquireTokenByClientCredential({
                    scopes: scopesArray,
                });
                if (authenticationResult) {
                    accessToken = {
                        token: authenticationResult.accessToken,
                        expiresOnTimestamp: authenticationResult.expiresOn.getTime(),
                    };
                }
            }
            catch (err) {
                const errorMsg = "Get M365 tenant credential failed with error: " + err.message;
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, exports.ErrorCode.ServiceError);
            }
            if (!accessToken) {
                const errorMsg = "Get M365 tenant credential access token failed with empty access token";
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, exports.ErrorCode.InternalError);
            }
            return accessToken;
        });
    }
    /**
     * Load and validate authentication configuration
     *
     * @param {AuthenticationConfiguration} authConfig - The authentication configuration. Use environment variables if not provided.
     *
     * @returns Authentication configuration
     */
    loadAndValidateConfig(config) {
        internalLogger.verbose("Validate authentication configuration");
        if (config.clientId && (config.clientSecret || config.certificateContent) && config.tenantId) {
            return config;
        }
        const missingValues = [];
        if (!config.clientId) {
            missingValues.push("clientId");
        }
        if (!config.clientSecret && !config.certificateContent) {
            missingValues.push("clientSecret or certificateContent");
        }
        if (!config.tenantId) {
            missingValues.push("tenantId");
        }
        const errorMsg = formatString(ErrorMessage.InvalidConfiguration, missingValues.join(", "), "undefined");
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidConfiguration);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Represent on-behalf-of flow to get user identity, and it is designed to be used in server side.
 *
 * @example
 * ```typescript
 * const credential = new OnBehalfOfUserCredential(ssoToken);
 * ```
 *
 * @remarks
 * Can only be used in server side.
 */
class OnBehalfOfUserCredential {
    /**
     * Constructor of OnBehalfOfUserCredential
     *
     * @remarks
     * Only works in in server side.
     *
     * @param {string} ssoToken - User token provided by Teams SSO feature.
     * @param {AuthenticationConfiguration} config - The authentication configuration. Use environment variables if not provided.
     *
     * @throws {@link ErrorCode|InvalidConfiguration} when client id, client secret, certificate content, authority host or tenant id is not found in config.
     * @throws {@link ErrorCode|InternalError} when SSO token is not valid.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(ssoToken, config) {
        internalLogger.info("Get on behalf of user credential");
        const missingConfigurations = [];
        if (!config.clientId) {
            missingConfigurations.push("clientId");
        }
        if (!config.authorityHost) {
            missingConfigurations.push("authorityHost");
        }
        if (!config.clientSecret && !config.certificateContent) {
            missingConfigurations.push("clientSecret or certificateContent");
        }
        if (!config.tenantId) {
            missingConfigurations.push("tenantId");
        }
        if (missingConfigurations.length != 0) {
            const errorMsg = formatString(ErrorMessage.InvalidConfiguration, missingConfigurations.join(", "), "undefined");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidConfiguration);
        }
        this.msalClient = createConfidentialClientApplication(config);
        const decodedSsoToken = parseJwt(ssoToken);
        this.ssoToken = {
            token: ssoToken,
            expiresOnTimestamp: decodedSsoToken.exp,
        };
    }
    /**
     * Get access token from credential.
     *
     * @example
     * ```typescript
     * await credential.getToken([]) // Get SSO token using empty string array
     * await credential.getToken("") // Get SSO token using empty string
     * await credential.getToken([".default"]) // Get Graph access token with default scope using string array
     * await credential.getToken(".default") // Get Graph access token with default scope using string
     * await credential.getToken(["User.Read"]) // Get Graph access token for single scope using string array
     * await credential.getToken("User.Read") // Get Graph access token for single scope using string
     * await credential.getToken(["User.Read", "Application.Read.All"]) // Get Graph access token for multiple scopes using string array
     * await credential.getToken("User.Read Application.Read.All") // Get Graph access token for multiple scopes using space-separated string
     * await credential.getToken("https://graph.microsoft.com/User.Read") // Get Graph access token with full resource URI
     * await credential.getToken(["https://outlook.office.com/Mail.Read"]) // Get Outlook access token
     * ```
     *
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     * @param {GetTokenOptions} options - The options used to configure any requests this TokenCredential implementation might make.
     *
     * @throws {@link ErrorCode|InternalError} when failed to acquire access token on behalf of user with unknown error.
     * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
     * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
     * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns Access token with expected scopes.
     *
     * @remarks
     * If scopes is empty string or array, it returns SSO token.
     * If scopes is non-empty, it returns access token for target scope.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateScopesType(scopes);
            const scopesArray = getScopesArray(scopes);
            let result;
            if (!scopesArray.length) {
                internalLogger.info("Get SSO token.");
                if (Math.floor(Date.now() / 1000) > this.ssoToken.expiresOnTimestamp) {
                    const errorMsg = "Sso token has already expired.";
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(errorMsg, exports.ErrorCode.TokenExpiredError);
                }
                result = this.ssoToken;
            }
            else {
                internalLogger.info("Get access token with scopes: " + scopesArray.join(" "));
                let authenticationResult;
                try {
                    authenticationResult = yield this.msalClient.acquireTokenOnBehalfOf({
                        oboAssertion: this.ssoToken.token,
                        scopes: scopesArray,
                    });
                }
                catch (error) {
                    throw this.generateAuthServerError(error);
                }
                if (!authenticationResult) {
                    const errorMsg = "Access token is null";
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(formatString(ErrorMessage.FailToAcquireTokenOnBehalfOfUser, errorMsg), exports.ErrorCode.InternalError);
                }
                result = {
                    token: authenticationResult.accessToken,
                    expiresOnTimestamp: authenticationResult.expiresOn.getTime(),
                };
            }
            return result;
        });
    }
    /**
     * Get basic user info from SSO token.
     *
     * @example
     * ```typescript
     * const currentUser = getUserInfo();
     * ```
     *
     * @throws {@link ErrorCode|InternalError} when SSO token is not valid.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns Basic user info with user displayName, objectId and preferredUserName.
     */
    getUserInfo() {
        internalLogger.info("Get basic user info from SSO token");
        return getUserInfoFromSsoToken(this.ssoToken.token);
    }
    generateAuthServerError(err) {
        const errorMessage = err.errorMessage;
        if (err.name === "InteractionRequiredAuthError") {
            const fullErrorMsg = "Failed to get access token from AAD server, interaction required: " + errorMessage;
            internalLogger.warn(fullErrorMsg);
            return new ErrorWithCode(fullErrorMsg, exports.ErrorCode.UiRequiredError);
        }
        else if (errorMessage && errorMessage.indexOf("AADSTS500133") >= 0) {
            const fullErrorMsg = "Failed to get access token from AAD server, sso token expired: " + errorMessage;
            internalLogger.error(fullErrorMsg);
            return new ErrorWithCode(fullErrorMsg, exports.ErrorCode.TokenExpiredError);
        }
        else {
            const fullErrorMsg = formatString(ErrorMessage.FailToAcquireTokenOnBehalfOfUser, errorMessage);
            internalLogger.error(fullErrorMsg);
            return new ErrorWithCode(fullErrorMsg, exports.ErrorCode.ServiceError);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Represent Teams current user's identity, and it is used within Teams client applications.
 *
 * @remarks
 * Can only be used within Teams.
 */
class TeamsUserCredential {
    /**
     * Constructor of TeamsUserCredential.
     * @remarks
     * Can only be used within Teams.
     */
    constructor(authConfig) {
        throw new ErrorWithCode(formatString(ErrorMessage.NodejsRuntimeNotSupported, "TeamsUserCredential"), exports.ErrorCode.RuntimeNotSupported);
    }
    /**
     * Popup login page to get user's access token with specific scopes.
     * @remarks
     * Can only be used within Teams.
     */
    login(scopes) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.NodejsRuntimeNotSupported, "TeamsUserCredential"), exports.ErrorCode.RuntimeNotSupported);
        });
    }
    /**
     * Get access token from credential.
     * @remarks
     * Can only be used within Teams.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.NodejsRuntimeNotSupported, "TeamsUserCredential"), exports.ErrorCode.RuntimeNotSupported);
        });
    }
    /**
     * Get basic user info from SSO token
     * @remarks
     * Can only be used within Teams.
     */
    getUserInfo() {
        throw new ErrorWithCode(formatString(ErrorMessage.NodejsRuntimeNotSupported, "TeamsUserCredential"), exports.ErrorCode.RuntimeNotSupported);
    }
}

// Copyright (c) Microsoft Corporation.
const defaultScope = "https://graph.microsoft.com/.default";
/**
 * Microsoft Graph auth provider for Teams Framework
 */
class MsGraphAuthProvider {
    /**
     * Constructor of MsGraphAuthProvider.
     *
     * @param {TeamsFx} teamsfx - Used to provide configuration and auth.
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     *
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     *
     * @returns An instance of MsGraphAuthProvider.
     */
    constructor(teamsfx, scopes) {
        this.teamsfx = teamsfx;
        let scopesStr = defaultScope;
        if (scopes) {
            validateScopesType(scopes);
            scopesStr = typeof scopes === "string" ? scopes : scopes.join(" ");
            if (scopesStr === "") {
                scopesStr = defaultScope;
            }
        }
        internalLogger.info(`Create Microsoft Graph Authentication Provider with scopes: '${scopesStr}'`);
        this.scopes = scopesStr;
    }
    /**
     * Get access token for Microsoft Graph API requests.
     *
     * @throws {@link ErrorCode|InternalError} when get access token failed due to empty token or unknown other problems.
     * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
     * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
     * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth or AAD server.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     *
     * @returns Access token from the credential.
     *
     */
    getAccessToken() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            internalLogger.info(`Get Graph Access token with scopes: '${this.scopes}'`);
            const accessToken = yield this.teamsfx.getCredential().getToken(this.scopes);
            return new Promise((resolve, reject) => {
                if (accessToken) {
                    resolve(accessToken.token);
                }
                else {
                    const errorMsg = "Graph access token is undefined or empty";
                    internalLogger.error(errorMsg);
                    reject(new ErrorWithCode(errorMsg, exports.ErrorCode.InternalError));
                }
            });
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Get Microsoft graph client.
 *
 * @example
 * Get Microsoft graph client by TokenCredential
 * ```typescript
 * // Sso token example (Azure Function)
 * const ssoToken = "YOUR_TOKEN_STRING";
 * const options = {"AAD_APP_ID", "AAD_APP_SECRET"};
 * const credential = new OnBehalfOfAADUserCredential(ssoToken, options);
 * const graphClient = await createMicrosoftGraphClient(credential);
 * const profile = await graphClient.api("/me").get();
 *
 * // TeamsBotSsoPrompt example (Bot Application)
 * const requiredScopes = ["User.Read"];
 * const config: Configuration = {
 *    loginUrl: loginUrl,
 *    clientId: clientId,
 *    clientSecret: clientSecret,
 *    tenantId: tenantId
 * };
 * const prompt = new TeamsBotSsoPrompt(dialogId, {
 *    config: config
 *    scopes: '["User.Read"],
 * });
 * this.addDialog(prompt);
 *
 * const oboCredential = new OnBehalfOfAADUserCredential(
 *  getUserId(dialogContext),
 *  {
 *    clientId: "AAD_APP_ID",
 *    clientSecret: "AAD_APP_SECRET"
 *  });
 * try {
 *    const graphClient = await createMicrosoftGraphClient(credential);
 *    const profile = await graphClient.api("/me").get();
 * } catch (e) {
 *    dialogContext.beginDialog(dialogId);
 *    return Dialog.endOfTurn();
 * }
 * ```
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth.
 * @param scopes - The array of Microsoft Token scope of access. Default value is `[.default]`.
 *
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 *
 * @returns Graph client with specified scopes.
 */
function createMicrosoftGraphClient(teamsfx, scopes) {
    internalLogger.info("Create Microsoft Graph Client");
    const authProvider = new MsGraphAuthProvider(teamsfx, scopes);
    const graphClient = microsoftGraphClient.Client.initWithMiddleware({
        authProvider,
    });
    return graphClient;
}

// Copyright (c) Microsoft Corporation.
/**
 * MSSQL default scope
 * https://docs.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-connect-msi
 */
const defaultSQLScope = "https://database.windows.net/";
/**
 * Generate connection configuration consumed by tedious.
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 * @param { string? } databaseName - specify database name to override default one if there are multiple databases.
 *
 * @returns Connection configuration of tedious for the SQL.
 *
 * @throws {@link ErrorCode|InvalidConfiguration} when SQL config resource configuration is invalid.
 * @throws {@link ErrorCode|InternalError} when get user MSI token failed or MSI token is invalid.
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
 */
function getTediousConnectionConfig(teamsfx, databaseName) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        internalLogger.info("Get SQL configuration");
        try {
            isSQLConfigurationValid(teamsfx);
        }
        catch (err) {
            throw err;
        }
        if (databaseName === "") {
            internalLogger.warn(`SQL database name is empty string`);
        }
        const dbName = databaseName !== null && databaseName !== void 0 ? databaseName : (teamsfx.hasConfig("sqlDatabaseName") ? teamsfx.getConfig("sqlDatabaseName") : undefined);
        if (!isMsiAuthentication(teamsfx)) {
            const configWithUPS = generateDefaultConfig(teamsfx, dbName);
            internalLogger.verbose("SQL configuration with username and password generated");
            return configWithUPS;
        }
        try {
            const configWithToken = yield generateTokenConfig(teamsfx, dbName);
            internalLogger.verbose("SQL configuration with MSI token generated");
            return configWithToken;
        }
        catch (error) {
            throw error;
        }
    });
}
/**
 * check configuration is an available configurations.
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 *
 * @returns true - SQL configuration has a valid SQL endpoints, SQL username with password or identity ID.
 *          false - configuration is not valid.
 * @internal
 */
function isSQLConfigurationValid(teamsfx) {
    internalLogger.verbose("Check SQL configuration if valid");
    if (!teamsfx.hasConfig("sqlServerEndpoint")) {
        internalLogger.error("SQL configuration is not valid without SQL server endpoint exist");
        throw new ErrorWithCode("SQL configuration error without SQL server endpoint exist", exports.ErrorCode.InvalidConfiguration);
    }
    if (!(teamsfx.hasConfig("sqlUsername") && teamsfx.hasConfig("sqlPassword")) &&
        !teamsfx.hasConfig("sqlIdentityId")) {
        const errMsg = `SQL configuration is not valid without ${teamsfx.hasConfig("sqlIdentityId") ? "" : "identity id "} ${teamsfx.hasConfig("sqlUsername") ? "" : "SQL username "} ${teamsfx.hasConfig("sqlPassword") ? "" : "SQL password"} exist`;
        internalLogger.error(errMsg);
        throw new ErrorWithCode(errMsg, exports.ErrorCode.InvalidConfiguration);
    }
    internalLogger.verbose("SQL configuration is valid");
}
/**
 * Check SQL use MSI identity or username and password.
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 *
 * @returns false - login with SQL MSI identity, true - login with username and password.
 * @internal
 */
function isMsiAuthentication(teamsfx) {
    internalLogger.verbose("Check connection config using MSI access token or username and password");
    if (teamsfx.hasConfig("sqlUsername") && teamsfx.hasConfig("sqlPassword")) {
        internalLogger.verbose("Login with username and password");
        return false;
    }
    internalLogger.verbose("Login with MSI identity");
    return true;
}
/**
 * Generate tedious connection configuration with default authentication type.
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 * @param { string? } databaseName - specify database name to override default one if there are multiple databases.
 *
 * @returns Tedious connection configuration with username and password.
 * @internal
 */
function generateDefaultConfig(teamsfx, databaseName) {
    internalLogger.verbose(`SQL server ${teamsfx.getConfig("sqlServerEndpoint")}
    , user name ${teamsfx.getConfig("sqlUsername")}
    , database name ${databaseName}`);
    const config = {
        server: teamsfx.getConfig("sqlServerEndpoint"),
        authentication: {
            type: TediousAuthenticationType.default,
            options: {
                userName: teamsfx.getConfig("sqlUsername"),
                password: teamsfx.getConfig("sqlPassword"),
            },
        },
        options: {
            database: databaseName,
            encrypt: true,
        },
    };
    return config;
}
/**
 * Generate tedious connection configuration with azure-active-directory-access-token authentication type.
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 *
 * @returns Tedious connection configuration with access token.
 * @internal
 */
function generateTokenConfig(teamsfx, databaseName) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        internalLogger.verbose("Generate tedious config with MSI token");
        let token;
        try {
            const credential = new identity.ManagedIdentityCredential(teamsfx.getConfig("sqlIdentityId"));
            token = yield credential.getToken(defaultSQLScope);
        }
        catch (error) {
            const errMsg = "Get user MSI token failed";
            internalLogger.error(errMsg);
            throw new ErrorWithCode(errMsg, exports.ErrorCode.InternalError);
        }
        if (token) {
            const config = {
                server: teamsfx.getConfig("sqlServerEndpoint"),
                authentication: {
                    type: TediousAuthenticationType.MSI,
                    options: {
                        token: token.token,
                    },
                },
                options: {
                    database: databaseName,
                    encrypt: true,
                },
            };
            internalLogger.verbose(`Generate token configuration success
      , server endpoint is ${teamsfx.getConfig("sqlServerEndpoint")}
      , database name is ${databaseName}`);
            return config;
        }
        internalLogger.error(`Generate token configuration
    , server endpoint is ${teamsfx.getConfig("sqlServerEndpoint")}
    , MSI token is not valid`);
        throw new ErrorWithCode("MSI token is not valid", exports.ErrorCode.InternalError);
    });
}
/**
 * tedious connection config authentication type.
 * https://tediousjs.github.io/tedious/api-connection.html
 * @internal
 */
var TediousAuthenticationType;
(function (TediousAuthenticationType) {
    TediousAuthenticationType["default"] = "default";
    TediousAuthenticationType["MSI"] = "azure-active-directory-access-token";
})(TediousAuthenticationType || (TediousAuthenticationType = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Identity type to use in authentication.
 */
exports.IdentityType = void 0;
(function (IdentityType) {
    /**
     * Represents the current user of Teams.
     */
    IdentityType["User"] = "User";
    /**
     * Represents the application itself.
     */
    IdentityType["App"] = "Application";
})(exports.IdentityType || (exports.IdentityType = {}));

// Copyright (c) Microsoft Corporation.
const invokeResponseType = "invokeResponse";
/**
 * Response body returned for a token exchange invoke activity.
 */
class TokenExchangeInvokeResponse {
    constructor(id, failureDetail) {
        this.id = id;
        this.failureDetail = failureDetail;
    }
}
/**
 * Creates a new prompt that leverage Teams Single Sign On (SSO) support for bot to automatically sign in user and
 * help receive oauth token, asks the user to consent if needed.
 *
 * @remarks
 * The prompt will attempt to retrieve the users current token of the desired scopes and store it in
 * the token store.
 *
 * User will be automatically signed in leveraging Teams support of Bot Single Sign On(SSO):
 * https://docs.microsoft.com/en-us/microsoftteams/platform/bots/how-to/authentication/auth-aad-sso-bots
 *
 * @example
 * When used with your bots `DialogSet` you can simply add a new instance of the prompt as a named
 * dialog using `DialogSet.add()`. You can then start the prompt from a waterfall step using either
 * `DialogContext.beginDialog()` or `DialogContext.prompt()`. The user will be prompted to sign in as
 * needed and their access token will be passed as an argument to the callers next waterfall step:
 *
 * ```JavaScript
 * const { ConversationState, MemoryStorage } = require('botbuilder');
 * const { DialogSet, WaterfallDialog } = require('botbuilder-dialogs');
 * const { TeamsBotSsoPrompt } = require('@microsoft/teamsfx');
 *
 * const convoState = new ConversationState(new MemoryStorage());
 * const dialogState = convoState.createProperty('dialogState');
 * const dialogs = new DialogSet(dialogState);
 *
 * dialogs.add(new TeamsBotSsoPrompt('TeamsBotSsoPrompt', {
 *    scopes: ["User.Read"],
 * }));
 *
 * dialogs.add(new WaterfallDialog('taskNeedingLogin', [
 *      async (step) => {
 *          return await step.beginDialog('TeamsBotSsoPrompt');
 *      },
 *      async (step) => {
 *          const token = step.result;
 *          if (token) {
 *
 *              // ... continue with task needing access token ...
 *
 *          } else {
 *              await step.context.sendActivity(`Sorry... We couldn't log you in. Try again later.`);
 *              return await step.endDialog();
 *          }
 *      }
 * ]));
 * ```
 */
class TeamsBotSsoPrompt extends botbuilderDialogs.Dialog {
    /**
     * Constructor of TeamsBotSsoPrompt.
     *
     * @param {TeamsFx} teamsfx - Used to provide configuration and auth
     * @param dialogId Unique ID of the dialog within its parent `DialogSet` or `ComponentDialog`.
     * @param settings Settings used to configure the prompt.
     *
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(teamsfx, dialogId, settings) {
        super(dialogId);
        this.teamsfx = teamsfx;
        this.settings = settings;
        validateScopesType(settings.scopes);
        this.loadAndValidateConfig();
        internalLogger.info("Create a new Teams Bot SSO Prompt");
    }
    /**
     * Called when a prompt dialog is pushed onto the dialog stack and is being activated.
     * @remarks
     * If the task is successful, the result indicates whether the prompt is still
     * active after the turn has been processed by the prompt.
     *
     * @param dc The DialogContext for the current turn of the conversation.
     *
     * @throws {@link ErrorCode|InvalidParameter} when timeout property in teams bot sso prompt settings is not number or is not positive.
     * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns A `Promise` representing the asynchronous operation.
     */
    beginDialog(dc) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            internalLogger.info("Begin Teams Bot SSO Prompt");
            this.ensureMsTeamsChannel(dc);
            // Initialize prompt state
            const default_timeout = 900000;
            let timeout = default_timeout;
            if (this.settings.timeout) {
                if (typeof this.settings.timeout != "number") {
                    const errorMsg = "type of timeout property in teamsBotSsoPromptSettings should be number.";
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidParameter);
                }
                if (this.settings.timeout <= 0) {
                    const errorMsg = "value of timeout property in teamsBotSsoPromptSettings should be positive.";
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidParameter);
                }
                timeout = this.settings.timeout;
            }
            if (this.settings.endOnInvalidMessage === undefined) {
                this.settings.endOnInvalidMessage = true;
            }
            const state = (_a = dc.activeDialog) === null || _a === void 0 ? void 0 : _a.state;
            state.state = {};
            state.options = {};
            state.expires = new Date().getTime() + timeout;
            // Send OAuth card to get SSO token
            yield this.sendOAuthCardAsync(dc.context);
            return botbuilderDialogs.Dialog.EndOfTurn;
        });
    }
    /**
     * Called when a prompt dialog is the active dialog and the user replied with a new activity.
     *
     * @remarks
     * If the task is successful, the result indicates whether the dialog is still
     * active after the turn has been processed by the dialog.
     * The prompt generally continues to receive the user's replies until it accepts the
     * user's reply as valid input for the prompt.
     *
     * @param dc The DialogContext for the current turn of the conversation.
     *
     * @returns A `Promise` representing the asynchronous operation.
     *
     * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    continueDialog(dc) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            internalLogger.info("Continue Teams Bot SSO Prompt");
            this.ensureMsTeamsChannel(dc);
            // Check for timeout
            const state = (_a = dc.activeDialog) === null || _a === void 0 ? void 0 : _a.state;
            const isMessage = dc.context.activity.type === botbuilder.ActivityTypes.Message;
            const isTimeoutActivityType = isMessage ||
                this.isTeamsVerificationInvoke(dc.context) ||
                this.isTokenExchangeRequestInvoke(dc.context);
            // If the incoming Activity is a message, or an Activity Type normally handled by TeamsBotSsoPrompt,
            // check to see if this TeamsBotSsoPrompt Expiration has elapsed, and end the dialog if so.
            const hasTimedOut = isTimeoutActivityType && new Date().getTime() > state.expires;
            if (hasTimedOut) {
                internalLogger.warn("End Teams Bot SSO Prompt due to timeout");
                return yield dc.endDialog(undefined);
            }
            else {
                if (this.isTeamsVerificationInvoke(dc.context) ||
                    this.isTokenExchangeRequestInvoke(dc.context)) {
                    // Recognize token
                    const recognized = yield this.recognizeToken(dc);
                    if (recognized.succeeded) {
                        return yield dc.endDialog(recognized.value);
                    }
                }
                else if (isMessage && this.settings.endOnInvalidMessage) {
                    internalLogger.warn("End Teams Bot SSO Prompt due to invalid message");
                    return yield dc.endDialog(undefined);
                }
                return botbuilderDialogs.Dialog.EndOfTurn;
            }
        });
    }
    loadAndValidateConfig() {
        if (this.teamsfx.getIdentityType() !== exports.IdentityType.User) {
            const errorMsg = formatString(ErrorMessage.IdentityTypeNotSupported, this.teamsfx.getIdentityType().toString(), "TeamsBotSsoPrompt");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.IdentityTypeNotSupported);
        }
        const missingConfigurations = [];
        if (!this.teamsfx.hasConfig("initiateLoginEndpoint")) {
            missingConfigurations.push("initiateLoginEndpoint");
        }
        if (!this.teamsfx.hasConfig("clientId")) {
            missingConfigurations.push("clientId");
        }
        if (!this.teamsfx.hasConfig("tenantId")) {
            missingConfigurations.push("tenantId");
        }
        if (!this.teamsfx.hasConfig("applicationIdUri")) {
            missingConfigurations.push("applicationIdUri");
        }
        if (missingConfigurations.length != 0) {
            const errorMsg = formatString(ErrorMessage.InvalidConfiguration, missingConfigurations.join(", "), "undefined");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidConfiguration);
        }
    }
    /**
     * Ensure bot is running in MS Teams since TeamsBotSsoPrompt is only supported in MS Teams channel.
     * @param dc dialog context
     * @throws {@link ErrorCode|ChannelNotSupported} if bot channel is not MS Teams
     * @internal
     */
    ensureMsTeamsChannel(dc) {
        if (dc.context.activity.channelId != botbuilder.Channels.Msteams) {
            const errorMsg = formatString(ErrorMessage.OnlyMSTeamsChannelSupported, "Teams Bot SSO Prompt");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.ChannelNotSupported);
        }
    }
    /**
     * Send OAuthCard that tells Teams to obtain an authentication token for the bot application.
     * For details see https://docs.microsoft.com/en-us/microsoftteams/platform/bots/how-to/authentication/auth-aad-sso-bots.
     *
     * @internal
     */
    sendOAuthCardAsync(context) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            internalLogger.verbose("Send OAuth card to get SSO token");
            const account = yield botbuilder.TeamsInfo.getMember(context, context.activity.from.id);
            internalLogger.verbose("Get Teams member account user principal name: " + account.userPrincipalName);
            const loginHint = account.userPrincipalName ? account.userPrincipalName : "";
            const signInResource = this.getSignInResource(loginHint);
            const card = botbuilder.CardFactory.oauthCard("", "Teams SSO Sign In", "Sign In", signInResource.signInLink, signInResource.tokenExchangeResource);
            card.content.buttons[0].type = botbuilder.ActionTypes.Signin;
            const msg = botbuilder.MessageFactory.attachment(card);
            // Send prompt
            yield context.sendActivity(msg);
        });
    }
    /**
     * Get sign in resource.
     *
     * @throws {@link ErrorCode|InvalidConfiguration} if client id, tenant id or initiate login endpoint is not found in config.
     *
     * @internal
     */
    getSignInResource(loginHint) {
        internalLogger.verbose("Get sign in authentication configuration");
        const signInLink = `${this.teamsfx.getConfig("initiateLoginEndpoint")}?scope=${encodeURI(this.settings.scopes.join(" "))}&clientId=${this.teamsfx.getConfig("clientId")}&tenantId=${this.teamsfx.getConfig("tenantId")}&loginHint=${loginHint}`;
        internalLogger.verbose("Sign in link: " + signInLink);
        const tokenExchangeResource = {
            id: uuid.v4(),
            uri: this.teamsfx.getConfig("applicationIdUri").replace(/\/$/, "") + "/access_as_user",
        };
        internalLogger.verbose("Token exchange resource uri: " + tokenExchangeResource.uri);
        return {
            signInLink: signInLink,
            tokenExchangeResource: tokenExchangeResource,
        };
    }
    /**
     * @internal
     */
    recognizeToken(dc) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const context = dc.context;
            let tokenResponse;
            if (this.isTokenExchangeRequestInvoke(context)) {
                internalLogger.verbose("Receive token exchange request");
                // Received activity is not a token exchange request
                if (!(context.activity.value && this.isTokenExchangeRequest(context.activity.value))) {
                    const warningMsg = "The bot received an InvokeActivity that is missing a TokenExchangeInvokeRequest value. This is required to be sent with the InvokeActivity.";
                    internalLogger.warn(warningMsg);
                    yield context.sendActivity(this.getTokenExchangeInvokeResponse(botbuilder.StatusCodes.BAD_REQUEST, warningMsg));
                }
                else {
                    const ssoToken = context.activity.value.token;
                    this.teamsfx.setSsoToken(ssoToken);
                    const credential = this.teamsfx.getCredential();
                    let exchangedToken;
                    try {
                        exchangedToken = yield credential.getToken(this.settings.scopes);
                        if (exchangedToken) {
                            yield context.sendActivity(this.getTokenExchangeInvokeResponse(botbuilder.StatusCodes.OK, "", context.activity.value.id));
                            const ssoTokenExpiration = parseJwt(ssoToken).exp;
                            tokenResponse = {
                                ssoToken: ssoToken,
                                ssoTokenExpiration: new Date(ssoTokenExpiration * 1000).toISOString(),
                                connectionName: "",
                                token: exchangedToken.token,
                                expiration: exchangedToken.expiresOnTimestamp.toString(),
                            };
                        }
                    }
                    catch (error) {
                        const warningMsg = "The bot is unable to exchange token. Ask for user consent.";
                        internalLogger.info(warningMsg);
                        yield context.sendActivity(this.getTokenExchangeInvokeResponse(botbuilder.StatusCodes.PRECONDITION_FAILED, warningMsg, context.activity.value.id));
                    }
                }
            }
            else if (this.isTeamsVerificationInvoke(context)) {
                internalLogger.verbose("Receive Teams state verification request");
                yield this.sendOAuthCardAsync(dc.context);
                yield context.sendActivity({ type: invokeResponseType, value: { status: botbuilder.StatusCodes.OK } });
            }
            return tokenResponse !== undefined
                ? { succeeded: true, value: tokenResponse }
                : { succeeded: false };
        });
    }
    /**
     * @internal
     */
    getTokenExchangeInvokeResponse(status, failureDetail, id) {
        const invokeResponse = {
            type: invokeResponseType,
            value: { status, body: new TokenExchangeInvokeResponse(id, failureDetail) },
        };
        return invokeResponse;
    }
    /**
     * @internal
     */
    isTeamsVerificationInvoke(context) {
        const activity = context.activity;
        return activity.type === botbuilder.ActivityTypes.Invoke && activity.name === botbuilder.verifyStateOperationName;
    }
    /**
     * @internal
     */
    isTokenExchangeRequestInvoke(context) {
        const activity = context.activity;
        return activity.type === botbuilder.ActivityTypes.Invoke && activity.name === botbuilder.tokenExchangeOperationName;
    }
    /**
     * @internal
     */
    isTokenExchangeRequest(obj) {
        return obj.hasOwnProperty("token");
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Initializes new Axios instance with specific auth provider
 *
 * @param apiEndpoint - Base url of the API
 * @param authProvider - Auth provider that injects authentication info to each request
 * @returns axios instance configured with specfic auth provider
 *
 * @example
 * ```typescript
 * const client = createApiClient("https://my-api-endpoint-base-url", new BasicAuthProvider("xxx","xxx"));
 * ```
 */
function createApiClient(apiEndpoint, authProvider) {
    // Add a request interceptor
    const instance = axios__default["default"].create({
        baseURL: apiEndpoint,
    });
    instance.interceptors.request.use(function (config) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return yield authProvider.AddAuthenticationInfo(config);
        });
    });
    return instance;
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Bearer Token authentication
 */
class BearerTokenAuthProvider {
    /**
     * @param { () => Promise<string> } getToken - Function that returns the content of bearer token used in http request
     */
    constructor(getToken) {
        this.getToken = getToken;
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header already exists in request configuration.
     */
    AddAuthenticationInfo(config) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const token = yield this.getToken();
            if (!config.headers) {
                config.headers = {};
            }
            if (config.headers["Authorization"]) {
                throw new ErrorWithCode(ErrorMessage.AuthorizationHeaderAlreadyExists, exports.ErrorCode.AuthorizationInfoAlreadyExists);
            }
            config.headers["Authorization"] = `Bearer ${token}`;
            return config;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Basic authentication
 */
class BasicAuthProvider {
    /**
     *
     * @param { string } userName - Username used in basic auth
     * @param { string } password - Password used in basic auth
     *
     * @throws {@link ErrorCode|InvalidParameter} - when username or password is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(userName, password) {
        if (!userName) {
            throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "username"), exports.ErrorCode.InvalidParameter);
        }
        if (!password) {
            throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "password"), exports.ErrorCode.InvalidParameter);
        }
        this.userName = userName;
        this.password = password;
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header or auth property already exists in request configuration.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (config.headers && config.headers["Authorization"]) {
                throw new ErrorWithCode(ErrorMessage.AuthorizationHeaderAlreadyExists, exports.ErrorCode.AuthorizationInfoAlreadyExists);
            }
            if (config.auth) {
                throw new ErrorWithCode(ErrorMessage.BasicCredentialAlreadyExists, exports.ErrorCode.AuthorizationInfoAlreadyExists);
            }
            config.auth = {
                username: this.userName,
                password: this.password,
            };
            return config;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles API Key authentication
 */
class ApiKeyProvider {
    /**
     *
     * @param { string } keyName - The name of request header or query parameter that specifies API Key
     * @param { string } keyValue - The value of API Key
     * @param { ApiKeyLocation } keyLocation - The location of API Key: request header or query parameter.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when key name or key value is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(keyName, keyValue, keyLocation) {
        if (!keyName) {
            throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "keyName"), exports.ErrorCode.InvalidParameter);
        }
        if (!keyValue) {
            throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "keyVaule"), exports.ErrorCode.InvalidParameter);
        }
        this.keyName = keyName;
        this.keyValue = keyValue;
        this.keyLocation = keyLocation;
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when API key already exists in request header or url query parameter.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            switch (this.keyLocation) {
                case exports.ApiKeyLocation.Header:
                    if (!config.headers) {
                        config.headers = {};
                    }
                    if (config.headers[this.keyName]) {
                        throw new ErrorWithCode(formatString(ErrorMessage.DuplicateApiKeyInHeader, this.keyName), exports.ErrorCode.AuthorizationInfoAlreadyExists);
                    }
                    config.headers[this.keyName] = this.keyValue;
                    break;
                case exports.ApiKeyLocation.QueryParams:
                    if (!config.params) {
                        config.params = {};
                    }
                    let urlHasDefinedApiKey = false;
                    if (config.url) {
                        const url = new URL(config.url, config.baseURL);
                        urlHasDefinedApiKey = url.searchParams.has(this.keyName);
                    }
                    if (config.params[this.keyName] || urlHasDefinedApiKey) {
                        throw new ErrorWithCode(formatString(ErrorMessage.DuplicateApiKeyInQueryParam, this.keyName), exports.ErrorCode.AuthorizationInfoAlreadyExists);
                    }
                    config.params[this.keyName] = this.keyValue;
                    break;
            }
            return config;
        });
    }
}
/**
 * Define available location for API Key location
 */
exports.ApiKeyLocation = void 0;
(function (ApiKeyLocation) {
    /**
     * The API Key is placed in request header
     */
    ApiKeyLocation[ApiKeyLocation["Header"] = 0] = "Header";
    /**
     * The API Key is placed in query parameter
     */
    ApiKeyLocation[ApiKeyLocation["QueryParams"] = 1] = "QueryParams";
})(exports.ApiKeyLocation || (exports.ApiKeyLocation = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Certificate authentication
 */
class CertificateAuthProvider {
    /**
     *
     * @param { SecureContextOptions } certOption - information about the cert used in http requests
     *
     * @throws {@link ErrorCode|InvalidParameter} - when cert option is empty.
     */
    constructor(certOption) {
        if (certOption && Object.keys(certOption).length !== 0) {
            this.certOption = certOption;
        }
        else {
            throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "certOption"), exports.ErrorCode.InvalidParameter);
        }
    }
    /**
     * Adds authentication info to http requests.
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when custom httpsAgent in the request has duplicate properties with certOption provided in constructor.
     */
    AddAuthenticationInfo(config) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!config.httpsAgent) {
                config.httpsAgent = new https.Agent(this.certOption);
            }
            else {
                const existingProperties = new Set(Object.keys(config.httpsAgent.options));
                for (const property of Object.keys(this.certOption)) {
                    if (existingProperties.has(property)) {
                        throw new ErrorWithCode(formatString(ErrorMessage.DuplicateHttpsOptionProperty, property), exports.ErrorCode.InvalidParameter);
                    }
                }
                Object.assign(config.httpsAgent.options, this.certOption);
            }
            return config;
        });
    }
}
/**
 * Helper to create SecureContextOptions from PEM format cert
 *
 * @param { string | Buffer } cert - The cert chain in PEM format
 * @param { string | Buffer } key - The private key for the cert chain
 * @param { {passphrase?: string; ca?: string | Buffer} } options - Optional settings when create the cert options.
 *
 * @returns Instance of SecureContextOptions
 *
 * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
 *
 */
function createPemCertOption(cert, key, options) {
    if (cert.length === 0) {
        throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "cert"), exports.ErrorCode.InvalidParameter);
    }
    if (key.length === 0) {
        throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "key"), exports.ErrorCode.InvalidParameter);
    }
    return {
        cert,
        key,
        passphrase: options === null || options === void 0 ? void 0 : options.passphrase,
        ca: options === null || options === void 0 ? void 0 : options.ca,
    };
}
/**
 * Helper to create SecureContextOptions from PFX format cert
 *
 * @param { string | Buffer } pfx - The content of .pfx file
 * @param { {passphrase?: string} } options - Optional settings when create the cert options.
 *
 * @returns Instance of SecureContextOptions
 *
 * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
 *
 */
function createPfxCertOption(pfx, options) {
    if (pfx.length === 0) {
        throw new ErrorWithCode(formatString(ErrorMessage.EmptyParameter, "pfx"), exports.ErrorCode.InvalidParameter);
    }
    return {
        pfx,
        passphrase: options === null || options === void 0 ? void 0 : options.passphrase,
    };
}

// Copyright (c) Microsoft Corporation.
// Following keys are used by SDK internally
const ReservedKey = new Set([
    "authorityHost",
    "tenantId",
    "clientId",
    "clientSecret",
    "initiateLoginEndpoint",
    "applicationIdUri",
    "apiEndpoint",
    "apiName",
    "sqlServerEndpoint",
    "sqlUsername",
    "sqlPassword",
    "sqlDatabaseName",
    "sqlIdentityId",
]);
/**
 * A class providing credential and configuration.
 */
class TeamsFx {
    /**
     * Constructor of TeamsFx
     *
     * @param {IdentityType} identityType - Choose user or app identity
     * @param customConfig - key/value pairs of customized configuration that overrides default ones.
     *
     * @throws {@link ErrorCode|IdentityTypeNotSupported} when setting app identity in browser.
     */
    constructor(identityType, customConfig) {
        this.identityType = identityType !== null && identityType !== void 0 ? identityType : exports.IdentityType.User;
        this.configuration = new Map();
        this.loadFromEnv();
        if (customConfig) {
            for (const key of Object.keys(customConfig)) {
                const value = customConfig[key];
                if (value) {
                    this.configuration.set(key, value);
                }
            }
        }
    }
    /**
     * Identity type set by user.
     *
     * @returns identity type.
     */
    getIdentityType() {
        return this.identityType;
    }
    /**
     * Credential instance according to identity type choice.
     *
     * @remarks If user identity is chose, will return {@link TeamsUserCredential}
     * in browser environment and {@link OnBehalfOfUserCredential} in NodeJS. If app
     * identity is chose, will return {@link AppCredential}.
     *
     * @returns instance implements TokenCredential interface.
     */
    getCredential() {
        if (this.identityType === exports.IdentityType.User) {
            if (this.oboUserCredential) {
                return this.oboUserCredential;
            }
            const errorMsg = "SSO token is required to user identity. Please use setSsoToken().";
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.InvalidParameter);
        }
        else {
            if (!this.appCredential) {
                this.appCredential = new AppCredential(Object.fromEntries(this.configuration));
            }
            return this.appCredential;
        }
    }
    /**
     * Get user information.
     * @returns UserInfo object.
     */
    getUserInfo() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.identityType !== exports.IdentityType.User) {
                const errorMsg = formatString(ErrorMessage.IdentityTypeNotSupported, this.identityType.toString(), "TeamsFx");
                internalLogger.error(errorMsg);
                throw new ErrorWithCode(errorMsg, exports.ErrorCode.IdentityTypeNotSupported);
            }
            return Promise.resolve(this.getCredential().getUserInfo());
        });
    }
    /**
     * Popup login page to get user's access token with specific scopes.
     *
     * @remarks
     * Only works in Teams client APP. User will be redirected to the authorization page to login and consent.
     *
     * @example
     * ```typescript
     * await teamsfx.login(["https://graph.microsoft.com/User.Read"]); // single scope using string array
     * await teamsfx.login("https://graph.microsoft.com/User.Read"); // single scopes using string
     * await teamsfx.login(["https://graph.microsoft.com/User.Read", "Calendars.Read"]); // multiple scopes using string array
     * await teamsfx.login("https://graph.microsoft.com/User.Read Calendars.Read"); // multiple scopes using string
     * ```
     * @param scopes - The list of scopes for which the token will have access, before that, we will request user to consent.
     *
     * @throws {@link ErrorCode|InternalError} when failed to login with unknown error.
     * @throws {@link ErrorCode|ConsentFailed} when user canceled or failed to consent.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    login(scopes) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.NodejsRuntimeNotSupported, "login"), exports.ErrorCode.RuntimeNotSupported);
        });
    }
    /**
     * Set SSO token when using user identity in NodeJS.
     * @param {string} ssoToken - used for on behalf of user flow.
     * @returns self instance.
     */
    setSsoToken(ssoToken) {
        if (this.identityType !== exports.IdentityType.User) {
            throw new Error();
        }
        this.oboUserCredential = new OnBehalfOfUserCredential(ssoToken, Object.fromEntries(this.configuration));
        return this;
    }
    /**
     * Usually used by service plugins to retrieve specific config
     * @param {string} key - configuration key.
     * @returns value in configuration.
     */
    getConfig(key) {
        const value = this.configuration.get(key);
        if (!value) {
            const errorMsg = `Cannot find ${key} in configuration`;
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, exports.ErrorCode.InternalError);
        }
        return value;
    }
    /**
     * Check the value of specific key.
     * @param {string} key - configuration key.
     * @returns true if corresponding value is not empty string.
     */
    hasConfig(key) {
        const value = this.configuration.get(key);
        return !!value;
    }
    /**
     * Get all configurations.
     * @returns key value mappings.
     */
    getConfigs() {
        const config = {};
        for (const key of this.configuration.keys()) {
            const value = this.configuration.get(key);
            if (value) {
                config[key] = value;
            }
        }
        return config;
    }
    /**
     * Load configuration from environment variables.
     */
    loadFromEnv() {
        const env = process.env;
        this.configuration.set("authorityHost", env.M365_AUTHORITY_HOST);
        this.configuration.set("tenantId", env.M365_TENANT_ID);
        this.configuration.set("clientId", env.M365_CLIENT_ID);
        this.configuration.set("clientSecret", env.M365_CLIENT_SECRET);
        this.configuration.set("initiateLoginEndpoint", env.INITIATE_LOGIN_ENDPOINT);
        this.configuration.set("applicationIdUri", env.M365_APPLICATION_ID_URI);
        this.configuration.set("apiEndpoint", env.API_ENDPOINT);
        this.configuration.set("apiName", env.API_NAME);
        this.configuration.set("sqlServerEndpoint", env.SQL_ENDPOINT);
        this.configuration.set("sqlUsername", env.SQL_USER_NAME);
        this.configuration.set("sqlPassword", env.SQL_PASSWORD);
        this.configuration.set("sqlDatabaseName", env.SQL_DATABASE_NAME);
        this.configuration.set("sqlIdentityId", env.IDENTITY_ID);
        Object.keys(env).forEach((key) => {
            if (ReservedKey.has(key)) {
                internalLogger.warn(`The name of environment variable ${key} is preserved. Will not load it as configuration.`);
            }
            this.configuration.set(key, env[key]);
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
function cloneConversation(conversation) {
    return JSON.parse(JSON.stringify(conversation));
}
/**
 * @internal
 */
function getTargetType(conversationReference) {
    var _a;
    const conversationType = (_a = conversationReference.conversation) === null || _a === void 0 ? void 0 : _a.conversationType;
    if (conversationType === "personal") {
        return "Person";
    }
    else if (conversationType === "groupChat") {
        return "Group";
    }
    else if (conversationType === "channel") {
        return "Channel";
    }
    else {
        return undefined;
    }
}
/**
 * @internal
 */
function getTeamsBotInstallationId(context) {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = context.activity) === null || _a === void 0 ? void 0 : _a.channelData) === null || _b === void 0 ? void 0 : _b.team) === null || _c === void 0 ? void 0 : _c.id) !== null && _d !== void 0 ? _d : context.activity.conversation.id;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
var ActivityType;
(function (ActivityType) {
    ActivityType[ActivityType["CurrentBotInstalled"] = 0] = "CurrentBotInstalled";
    ActivityType[ActivityType["CurrentBotMessaged"] = 1] = "CurrentBotMessaged";
    ActivityType[ActivityType["CurrentBotUninstalled"] = 2] = "CurrentBotUninstalled";
    ActivityType[ActivityType["TeamDeleted"] = 3] = "TeamDeleted";
    ActivityType[ActivityType["TeamRestored"] = 4] = "TeamRestored";
    ActivityType[ActivityType["Unknown"] = 5] = "Unknown";
})(ActivityType || (ActivityType = {}));
/**
 * @internal
 */
class NotificationMiddleware {
    constructor(options) {
        this.conversationReferenceStore = options.conversationReferenceStore;
    }
    onTurn(context, next) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const type = this.classifyActivity(context.activity);
            switch (type) {
                case ActivityType.CurrentBotInstalled:
                case ActivityType.TeamRestored: {
                    const reference = botbuilder.TurnContext.getConversationReference(context.activity);
                    yield this.conversationReferenceStore.set(reference);
                    break;
                }
                case ActivityType.CurrentBotMessaged: {
                    yield this.tryAddMessagedReference(context);
                    break;
                }
                case ActivityType.CurrentBotUninstalled:
                case ActivityType.TeamDeleted: {
                    const reference = botbuilder.TurnContext.getConversationReference(context.activity);
                    yield this.conversationReferenceStore.delete(reference);
                    break;
                }
            }
            yield next();
        });
    }
    classifyActivity(activity) {
        var _a, _b;
        const activityType = activity.type;
        if (activityType === "installationUpdate") {
            const action = (_a = activity.action) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (action === "add") {
                return ActivityType.CurrentBotInstalled;
            }
            else {
                return ActivityType.CurrentBotUninstalled;
            }
        }
        else if (activityType === "conversationUpdate") {
            const eventType = (_b = activity.channelData) === null || _b === void 0 ? void 0 : _b.eventType;
            if (eventType === "teamDeleted") {
                return ActivityType.TeamDeleted;
            }
            else if (eventType === "teamRestored") {
                return ActivityType.TeamRestored;
            }
        }
        else if (activityType === "message") {
            return ActivityType.CurrentBotMessaged;
        }
        return ActivityType.Unknown;
    }
    tryAddMessagedReference(context) {
        var _a, _b, _c, _d;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const reference = botbuilder.TurnContext.getConversationReference(context.activity);
            const conversationType = (_a = reference === null || reference === void 0 ? void 0 : reference.conversation) === null || _a === void 0 ? void 0 : _a.conversationType;
            if (conversationType === "personal" || conversationType === "groupChat") {
                if (!(yield this.conversationReferenceStore.check(reference))) {
                    yield this.conversationReferenceStore.set(reference);
                }
            }
            else if (conversationType === "channel") {
                const teamId = (_d = (_c = (_b = context.activity) === null || _b === void 0 ? void 0 : _b.channelData) === null || _c === void 0 ? void 0 : _c.team) === null || _d === void 0 ? void 0 : _d.id;
                if (teamId !== undefined) {
                    const teamReference = cloneConversation(reference);
                    teamReference.conversation.id = teamId;
                    if (!(yield this.conversationReferenceStore.check(teamReference))) {
                        yield this.conversationReferenceStore.set(teamReference);
                    }
                }
            }
        });
    }
}
class CommandResponseMiddleware {
    constructor(handlers) {
        this.commandHandlers = [];
        if (handlers && handlers.length > 0) {
            this.commandHandlers.push(...handlers);
        }
    }
    onTurn(context, next) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (context.activity.type === botbuilder.ActivityTypes.Message) {
                // Invoke corresponding command handler for the command response
                const commandText = this.getActivityText(context.activity);
                const message = {
                    text: commandText,
                };
                for (const handler of this.commandHandlers) {
                    const matchResult = this.shouldTrigger(handler.triggerPatterns, commandText);
                    // It is important to note that the command bot will stop processing handlers
                    // when the first command handler is matched.
                    if (!!matchResult) {
                        message.matches = Array.isArray(matchResult) ? matchResult : void 0;
                        const response = yield handler.handleCommandReceived(context, message);
                        if (typeof response === "string") {
                            yield context.sendActivity(response);
                        }
                        else {
                            const replyActivity = response;
                            if (replyActivity) {
                                yield context.sendActivity(replyActivity);
                            }
                        }
                    }
                }
            }
            yield next();
        });
    }
    matchPattern(pattern, text) {
        if (text) {
            if (typeof pattern === "string") {
                const regExp = new RegExp(pattern, "i");
                return regExp.test(text);
            }
            if (pattern instanceof RegExp) {
                const matches = text.match(pattern);
                return matches !== null && matches !== void 0 ? matches : false;
            }
        }
        return false;
    }
    shouldTrigger(patterns, text) {
        const expressions = Array.isArray(patterns) ? patterns : [patterns];
        for (const ex of expressions) {
            const arg = this.matchPattern(ex, text);
            if (arg)
                return arg;
        }
        return false;
    }
    getActivityText(activity) {
        let text = activity.text;
        const removedMentionText = botbuilder.TurnContext.removeRecipientMention(activity);
        if (removedMentionText) {
            text = removedMentionText
                .toLowerCase()
                .replace(/\n|\r\n/g, "")
                .trim();
        }
        return text;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A command bot for receiving commands and sending responses in Teams.
 *
 * @remarks
 * Ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
 */
class CommandBot {
    /**
     * Creates a new instance of the `CommandBot`.
     *
     * @param adapter The bound `BotFrameworkAdapter`.
     * @param options - initialize options
     */
    constructor(adapter, options) {
        this.middleware = new CommandResponseMiddleware(options === null || options === void 0 ? void 0 : options.commands);
        this.adapter = adapter.use(this.middleware);
    }
    /**
     * Registers a command into the command bot.
     *
     * @param command The command to registered.
     */
    registerCommand(command) {
        if (command) {
            this.middleware.commandHandlers.push(command);
        }
    }
    /**
     * Registers commands into the command bot.
     *
     * @param commands The command to registered.
     */
    registerCommands(commands) {
        if (commands) {
            this.middleware.commandHandlers.push(...commands);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
class LocalFileStorage {
    constructor(fileDir) {
        this.localFileName = ".notification.localstore.json";
        this.filePath = path__namespace.resolve(fileDir, this.localFileName);
    }
    read(key) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!(yield this.storeFileExists())) {
                return undefined;
            }
            const data = yield this.readFromFile();
            return data[key];
        });
    }
    list() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!(yield this.storeFileExists())) {
                return [];
            }
            const data = yield this.readFromFile();
            return Object.entries(data).map((entry) => entry[1]);
        });
    }
    write(key, object) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!(yield this.storeFileExists())) {
                yield this.writeToFile({ [key]: object });
                return;
            }
            const data = yield this.readFromFile();
            yield this.writeToFile(Object.assign(data, { [key]: object }));
        });
    }
    delete(key) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (yield this.storeFileExists()) {
                const data = yield this.readFromFile();
                if (data[key] !== undefined) {
                    delete data[key];
                    yield this.writeToFile(data);
                }
            }
        });
    }
    storeFileExists() {
        return new Promise((resolve) => {
            try {
                fs__namespace.access(this.filePath, (err) => {
                    if (err) {
                        resolve(false);
                    }
                    else {
                        resolve(true);
                    }
                });
            }
            catch (error) {
                resolve(false);
            }
        });
    }
    readFromFile() {
        return new Promise((resolve, reject) => {
            try {
                fs__namespace.readFile(this.filePath, { encoding: "utf-8" }, (err, rawData) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(JSON.parse(rawData));
                    }
                });
            }
            catch (error) {
                reject(error);
            }
        });
    }
    writeToFile(data) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                try {
                    const rawData = JSON.stringify(data, undefined, 2);
                    fs__namespace.writeFile(this.filePath, rawData, { encoding: "utf-8" }, (err) => {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve();
                        }
                    });
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
}
/**
 * @internal
 */
class ConversationReferenceStore {
    constructor(storage) {
        this.storage = storage;
    }
    check(reference) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const ref = yield this.storage.read(this.getKey(reference));
            return ref !== undefined;
        });
    }
    getAll() {
        return this.storage.list();
    }
    set(reference) {
        return this.storage.write(this.getKey(reference), reference);
    }
    delete(reference) {
        return this.storage.delete(this.getKey(reference));
    }
    getKey(reference) {
        var _a, _b;
        return `_${(_a = reference.conversation) === null || _a === void 0 ? void 0 : _a.tenantId}_${(_b = reference.conversation) === null || _b === void 0 ? void 0 : _b.id}`;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Send a plain text message to a notification target.
 *
 * @param target - the notification target.
 * @param text - the plain text message.
 * @returns A `Promise` representing the asynchronous operation.
 */
function sendMessage(target, text) {
    return target.sendMessage(text);
}
/**
 * Send an adaptive card message to a notification target.
 *
 * @param target - the notification target.
 * @param card - the adaptive card raw JSON.
 * @returns A `Promise` representing the asynchronous operation.
 */
function sendAdaptiveCard(target, card) {
    return target.sendAdaptiveCard(card);
}
/**
 * A {@link NotificationTarget} that represents a team channel.
 *
 * @remarks
 * It's recommended to get channels from {@link TeamsBotInstallation.channels()}.
 */
class Channel {
    /**
     * Constructor.
     *
     * @remarks
     * It's recommended to get channels from {@link TeamsBotInstallation.channels()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this channel is created from.
     * @param info - Detailed channel information.
     */
    constructor(parent, info) {
        /**
         * Notification target type. For channel it's always "Channel".
         */
        this.type = "Channel";
        this.parent = parent;
        this.info = info;
    }
    /**
     * Send a plain text message.
     *
     * @param text - the plain text message.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendMessage(text) {
        return this.parent.adapter.continueConversation(this.parent.conversationReference, (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const conversation = yield this.newConversation(context);
            yield this.parent.adapter.continueConversation(conversation, (ctx) => tslib.__awaiter(this, void 0, void 0, function* () {
                yield ctx.sendActivity(text);
            }));
        }));
    }
    /**
     * Send an adaptive card message.
     *
     * @param card - the adaptive card raw JSON.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendAdaptiveCard(card) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.parent.adapter.continueConversation(this.parent.conversationReference, (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                const conversation = yield this.newConversation(context);
                yield this.parent.adapter.continueConversation(conversation, (ctx) => tslib.__awaiter(this, void 0, void 0, function* () {
                    yield ctx.sendActivity({
                        attachments: [botbuilder.CardFactory.adaptiveCard(card)],
                    });
                }));
            }));
        });
    }
    /**
     * @internal
     */
    newConversation(context) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const reference = botbuilder.TurnContext.getConversationReference(context.activity);
            const channelConversation = cloneConversation(reference);
            channelConversation.conversation.id = this.info.id || "";
            return channelConversation;
        });
    }
}
/**
 * A {@link NotificationTarget} that represents a team member.
 *
 * @remarks
 * It's recommended to get members from {@link TeamsBotInstallation.members()}.
 */
class Member {
    /**
     * Constructor.
     *
     * @remarks
     * It's recommended to get members from {@link TeamsBotInstallation.members()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this member is created from.
     * @param account - Detailed member account information.
     */
    constructor(parent, account) {
        /**
         * Notification target type. For member it's always "Person".
         */
        this.type = "Person";
        this.parent = parent;
        this.account = account;
    }
    /**
     * Send a plain text message.
     *
     * @param text - the plain text message.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendMessage(text) {
        return this.parent.adapter.continueConversation(this.parent.conversationReference, (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            const conversation = yield this.newConversation(context);
            yield this.parent.adapter.continueConversation(conversation, (ctx) => tslib.__awaiter(this, void 0, void 0, function* () {
                yield ctx.sendActivity(text);
            }));
        }));
    }
    /**
     * Send an adaptive card message.
     *
     * @param card - the adaptive card raw JSON.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendAdaptiveCard(card) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.parent.adapter.continueConversation(this.parent.conversationReference, (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                const conversation = yield this.newConversation(context);
                yield this.parent.adapter.continueConversation(conversation, (ctx) => tslib.__awaiter(this, void 0, void 0, function* () {
                    yield ctx.sendActivity({
                        attachments: [botbuilder.CardFactory.adaptiveCard(card)],
                    });
                }));
            }));
        });
    }
    /**
     * @internal
     */
    newConversation(context) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const reference = botbuilder.TurnContext.getConversationReference(context.activity);
            const personalConversation = cloneConversation(reference);
            const connectorClient = context.turnState.get(this.parent.adapter.ConnectorClientKey);
            const conversation = yield connectorClient.conversations.createConversation({
                isGroup: false,
                tenantId: context.activity.conversation.tenantId,
                bot: context.activity.recipient,
                members: [this.account],
                channelData: {},
            });
            personalConversation.conversation.id = conversation.id;
            return personalConversation;
        });
    }
}
/**
 * A {@link NotificationTarget} that represents a bot installation. Teams Bot could be installed into
 * - Personal chat
 * - Group chat
 * - Team (by default the `General` channel)
 *
 * @remarks
 * It's recommended to get bot installations from {@link ConversationBot.installations()}.
 */
class TeamsBotInstallation {
    /**
     * Constructor
     *
     * @remarks
     * It's recommended to get bot installations from {@link ConversationBot.installations()}, instead of using this constructor.
     *
     * @param adapter - the bound `BotFrameworkAdapter`.
     * @param conversationReference - the bound `ConversationReference`.
     */
    constructor(adapter, conversationReference) {
        this.adapter = adapter;
        this.conversationReference = conversationReference;
        this.type = getTargetType(conversationReference);
    }
    /**
     * Send a plain text message.
     *
     * @param text - the plain text message.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendMessage(text) {
        return this.adapter.continueConversation(this.conversationReference, (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            yield context.sendActivity(text);
        }));
    }
    /**
     * Send an adaptive card message.
     *
     * @param card - the adaptive card raw JSON.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendAdaptiveCard(card) {
        return this.adapter.continueConversation(this.conversationReference, (context) => tslib.__awaiter(this, void 0, void 0, function* () {
            yield context.sendActivity({
                attachments: [botbuilder.CardFactory.adaptiveCard(card)],
            });
        }));
    }
    /**
     * Get channels from this bot installation.
     *
     * @returns an array of channels if bot is installed into a team, otherwise returns an empty array.
     */
    channels() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let teamsChannels = [];
            yield this.adapter.continueConversation(this.conversationReference, (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                const teamId = getTeamsBotInstallationId(context);
                if (teamId !== undefined) {
                    teamsChannels = yield botbuilder.TeamsInfo.getTeamChannels(context, teamId);
                }
            }));
            const channels = [];
            for (const channel of teamsChannels) {
                channels.push(new Channel(this, channel));
            }
            return channels;
        });
    }
    /**
     * Get members from this bot installation.
     *
     * @returns an array of members from where the bot is installed.
     */
    members() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const members = [];
            yield this.adapter.continueConversation(this.conversationReference, (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                let continuationToken;
                do {
                    const pagedMembers = yield botbuilder.TeamsInfo.getPagedMembers(context, undefined, continuationToken);
                    continuationToken = pagedMembers.continuationToken;
                    for (const member of pagedMembers.members) {
                        members.push(new Member(this, member));
                    }
                } while (continuationToken !== undefined);
            }));
            return members;
        });
    }
}
/**
 * Provide utilities to send notification to varies targets (e.g., member, group, channel).
 */
class NotificationBot {
    /**
     * constructor of the notification bot.
     *
     * @remarks
     * To ensure accuracy, it's recommended to initialize before handling any message.
     *
     * @param adapter - the bound `BotFrameworkAdapter`
     * @param options - initialize options
     */
    constructor(adapter, options) {
        var _a, _b;
        const storage = (_a = options === null || options === void 0 ? void 0 : options.storage) !== null && _a !== void 0 ? _a : new LocalFileStorage(path__namespace.resolve(process.env.RUNNING_ON_AZURE === "1" ? (_b = process.env.TEMP) !== null && _b !== void 0 ? _b : "./" : "./"));
        this.conversationReferenceStore = new ConversationReferenceStore(storage);
        this.adapter = adapter.use(new NotificationMiddleware({
            conversationReferenceStore: this.conversationReferenceStore,
        }));
    }
    /**
     * Get all targets where the bot is installed.
     *
     * @remarks
     * The result is retrieving from the persisted storage.
     *
     * @returns - an array of {@link TeamsBotInstallation}.
     */
    installations() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.conversationReferenceStore === undefined || this.adapter === undefined) {
                throw new Error("NotificationBot has not been initialized.");
            }
            const references = yield this.conversationReferenceStore.getAll();
            const targets = [];
            for (const reference of references) {
                // validate connection
                let valid = true;
                yield this.adapter.continueConversation(reference, (context) => tslib.__awaiter(this, void 0, void 0, function* () {
                    try {
                        // try get member to see if the installation is still valid
                        yield botbuilder.TeamsInfo.getPagedMembers(context, 1);
                    }
                    catch (error) {
                        if (error.code === "BotNotInConversationRoster") {
                            valid = false;
                        }
                    }
                }));
                if (valid) {
                    targets.push(new TeamsBotInstallation(this.adapter, reference));
                }
                else {
                    yield this.conversationReferenceStore.delete(reference);
                }
            }
            return targets;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provide utilities for bot conversation, including:
 *   - handle command and response.
 *   - send notification to varies targets (e.g., member, group, channel).
 *
 * @example
 * For command and response, you can register your commands through the constructor, or use the `registerCommand` and `registerCommands` API to add commands later.
 *
 * ```typescript
 * // register through constructor
 * const conversationBot = new ConversationBot({
 *   command: {
 *     enabled: true,
 *     commands: [ new HelloWorldCommandHandler() ],
 *   },
 * });
 *
 * // register through `register*` API
 * conversationBot.command.registerCommand(new HelpCommandHandler());
 * ```
 *
 * For notification, you can enable notification at initialization, then send notifications at any time.
 *
 * ```typescript
 * // enable through constructor
 * const conversationBot = new ConversationBot({
 *   notification: {
 *     enabled: true,
 *   },
 * });
 *
 * // get all bot installations and send message
 * for (const target of await conversationBot.notification.installations()) {
 *   await target.sendMessage("Hello Notification");
 * }
 *
 * // alternative - send message to all members
 * for (const target of await conversationBot.notification.installations()) {
 *   for (const member of await target.members()) {
 *     await member.sendMessage("Hello Notification");
 *   }
 * }
 * ```
 *
 * @remarks
 * Set `adapter` in {@link ConversationOptions} to use your own bot adapter.
 *
 * For command and response, ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
 *
 * For notification, set `notification.storage` in {@link ConversationOptions} to use your own storage implementation.
 */
class ConversationBot {
    /**
     * Creates new instance of the `ConversationBot`.
     *
     * @remarks
     * It's recommended to create your own adapter and storage for production environment instead of the default one.
     *
     * @param options - initialize options
     */
    constructor(options) {
        var _a, _b;
        if (options.adapter) {
            this.adapter = options.adapter;
        }
        else {
            this.adapter = this.createDefaultAdapter(options.adapterConfig);
        }
        if ((_a = options.command) === null || _a === void 0 ? void 0 : _a.enabled) {
            this.command = new CommandBot(this.adapter, options.command);
        }
        if ((_b = options.notification) === null || _b === void 0 ? void 0 : _b.enabled) {
            this.notification = new NotificationBot(this.adapter, options.notification);
        }
    }
    createDefaultAdapter(adapterConfig) {
        const adapter = adapterConfig === undefined
            ? new botbuilder.BotFrameworkAdapter({
                appId: process.env.BOT_ID,
                appPassword: process.env.BOT_PASSWORD,
            })
            : new botbuilder.BotFrameworkAdapter(adapterConfig);
        // the default error handler
        adapter.onTurnError = (context, error) => tslib.__awaiter(this, void 0, void 0, function* () {
            // This check writes out errors to console.
            console.error(`[onTurnError] unhandled error: ${error}`);
            // Send a trace activity, which will be displayed in Bot Framework Emulator
            yield context.sendTraceActivity("OnTurnError Trace", `${error}`, "https://www.botframework.com/schemas/error", "TurnError");
            // Send a message to the user
            yield context.sendActivity(`The bot encountered unhandled error: ${error.message}`);
            yield context.sendActivity("To continue to run this bot, please fix the bot source code.");
        });
        return adapter;
    }
    /**
     * The request handler to integrate with web request.
     *
     * @param req - an Express or Restify style request object.
     * @param res - an Express or Restify style response object.
     * @param logic - the additional function to handle bot context.
     *
     * @example
     * For example, to use with Restify:
     * ``` typescript
     * // The default/empty behavior
     * server.post("api/messages", conversationBot.requestHandler);
     *
     * // Or, add your own logic
     * server.post("api/messages", async (req, res) => {
     *   await conversationBot.requestHandler(req, res, async (context) => {
     *     // your-own-context-logic
     *   });
     * });
     * ```
     */
    requestHandler(req, res, logic) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (logic === undefined) {
                // create empty logic
                logic = () => tslib.__awaiter(this, void 0, void 0, function* () { });
            }
            yield this.adapter.processActivity(req, res, logic);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provides utility method to build bot message with cards that supported in Teams.
 */
class MessageBuilder {
    /**
     * Build a bot message activity attached with adaptive card.
     *
     * @param cardTemplate The adaptive card template.
     * @param data card data used to render the template.
     * @returns A bot message activity attached with an adaptive card.
     *
     * @example
     * ```javascript
     * const cardTemplate = {
     *   type: "AdaptiveCard",
     *   body: [
     *     {
     *       "type": "TextBlock",
     *       "text": "${title}",
     *       "size": "Large"
     *     },
     *     {
     *       "type": "TextBlock",
     *       "text": "${description}"
     *     }],
     *     $schema: "http://adaptivecards.io/schemas/adaptive-card.json",
     *     version: "1.4"
     *  };
     *
     * type CardData = {
     *   title: string,
     *   description: string
     * };
     * const card = MessageBuilder.attachAdaptiveCard<CardData>(
     *   cardTemplate, {
     *   title: "sample card title",
     *   description: "sample card description"
     * });
     * ```
     */
    static attachAdaptiveCard(cardTemplate, data) {
        return {
            attachments: [botbuilder.CardFactory.adaptiveCard(adaptivecardsTools.AdaptiveCards.declare(cardTemplate).render(data))],
        };
    }
    /**
     * Build a bot message activity attached with an adaptive card.
     *
     * @param card The adaptive card content.
     * @returns A bot message activity attached with an adaptive card.
     */
    static attachAdaptiveCardWithoutData(card) {
        return {
            attachments: [botbuilder.CardFactory.adaptiveCard(adaptivecardsTools.AdaptiveCards.declareWithoutData(card).render())],
        };
    }
    /**
     * Build a bot message activity attached with an hero card.
     *
     * @param title The card title.
     * @param images Optional. The array of images to include on the card.
     * @param buttons Optional. The array of buttons to include on the card. Each `string` in the array
     *      is converted to an `imBack` button with a title and value set to the value of the string.
     * @param other Optional. Any additional properties to include on the card.
     *
     * @returns A bot message activity attached with a hero card.
     *
     * @example
     * ```javascript
     * const message = MessageBuilder.attachHeroCard(
     *      'sample title',
     *      ['https://example.com/sample.jpg'],
     *      ['action']
     * );
     * ```
     */
    static attachHeroCard(title, images, buttons, other) {
        return MessageBuilder.attachContent(botbuilder.CardFactory.heroCard(title, images, buttons, other));
    }
    /**
     * Returns an attachment for a sign-in card.
     *
     * @param title The title for the card's sign-in button.
     * @param url The URL of the sign-in page to use.
     * @param text Optional. Additional text to include on the card.
     *
     * @returns A bot message activity attached with a sign-in card.
     *
     * @remarks
     * For channels that don't natively support sign-in cards, an alternative message is rendered.
     */
    static attachSigninCard(title, url, text) {
        return MessageBuilder.attachContent(botbuilder.CardFactory.signinCard(title, url, text));
    }
    /**
     * Build a bot message activity attached with an Office 365 connector card.
     *
     * @param card A description of the Office 365 connector card.
     * @returns A bot message activity attached with an Office 365 connector card.
     */
    static attachO365ConnectorCard(card) {
        return MessageBuilder.attachContent(botbuilder.CardFactory.o365ConnectorCard(card));
    }
    /**
     * Build a message activity attached with a receipt card.
     * @param card A description of the receipt card.
     * @returns A message activity attached with a receipt card.
     */
    static AttachReceiptCard(card) {
        return MessageBuilder.attachContent(botbuilder.CardFactory.receiptCard(card));
    }
    /**
     *
     * @param title The card title.
     * @param images Optional. The array of images to include on the card.
     * @param buttons Optional. The array of buttons to include on the card. Each `string` in the array
     *      is converted to an `imBack` button with a title and value set to the value of the string.
     * @param other Optional. Any additional properties to include on the card.
     * @returns A message activity attached with a thumbnail card
     */
    static attachThumbnailCard(title, images, buttons, other) {
        return MessageBuilder.attachContent(botbuilder.CardFactory.thumbnailCard(title, images, buttons, other));
    }
    /**
     * Add an attachement to a bot activity.
     * @param attachement The attachment object to attach.
     * @returns A message activity with an attachment.
     */
    static attachContent(attachement) {
        return {
            attachments: [attachement],
        };
    }
}

exports.ApiKeyProvider = ApiKeyProvider;
exports.AppCredential = AppCredential;
exports.BasicAuthProvider = BasicAuthProvider;
exports.BearerTokenAuthProvider = BearerTokenAuthProvider;
exports.CertificateAuthProvider = CertificateAuthProvider;
exports.Channel = Channel;
exports.CommandBot = CommandBot;
exports.ConversationBot = ConversationBot;
exports.ErrorWithCode = ErrorWithCode;
exports.Member = Member;
exports.MessageBuilder = MessageBuilder;
exports.MsGraphAuthProvider = MsGraphAuthProvider;
exports.NotificationBot = NotificationBot;
exports.OnBehalfOfUserCredential = OnBehalfOfUserCredential;
exports.TeamsBotInstallation = TeamsBotInstallation;
exports.TeamsBotSsoPrompt = TeamsBotSsoPrompt;
exports.TeamsFx = TeamsFx;
exports.TeamsUserCredential = TeamsUserCredential;
exports.createApiClient = createApiClient;
exports.createMicrosoftGraphClient = createMicrosoftGraphClient;
exports.createPemCertOption = createPemCertOption;
exports.createPfxCertOption = createPfxCertOption;
exports.getLogLevel = getLogLevel;
exports.getTediousConnectionConfig = getTediousConnectionConfig;
exports.sendAdaptiveCard = sendAdaptiveCard;
exports.sendMessage = sendMessage;
exports.setLogFunction = setLogFunction;
exports.setLogLevel = setLogLevel;
exports.setLogger = setLogger;
//# sourceMappingURL=index.node.cjs.js.map
