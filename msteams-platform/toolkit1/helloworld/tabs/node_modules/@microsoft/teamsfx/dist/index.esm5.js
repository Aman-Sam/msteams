import { __awaiter } from 'tslib';
import jwt_decode from 'jwt-decode';
import * as microsoftTeams from '@microsoft/teams-js';
import { PublicClientApplication } from '@azure/msal-browser';
import { Client } from '@microsoft/microsoft-graph-client';
import axios from 'axios';

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Error code to trace the error types.
 */
var ErrorCode;
(function (ErrorCode) {
    /**
     * Invalid parameter error.
     */
    ErrorCode["InvalidParameter"] = "InvalidParameter";
    /**
     * Invalid configuration error.
     */
    ErrorCode["InvalidConfiguration"] = "InvalidConfiguration";
    /**
     * Invalid certificate error.
     */
    ErrorCode["InvalidCertificate"] = "InvalidCertificate";
    /**
     * Internal error.
     */
    ErrorCode["InternalError"] = "InternalError";
    /**
     * Channel is not supported error.
     */
    ErrorCode["ChannelNotSupported"] = "ChannelNotSupported";
    /**
     * Runtime is not supported error.
     */
    ErrorCode["RuntimeNotSupported"] = "RuntimeNotSupported";
    /**
     * User failed to finish the AAD consent flow failed.
     */
    ErrorCode["ConsentFailed"] = "ConsentFailed";
    /**
     * The user or administrator has not consented to use the application error.
     */
    ErrorCode["UiRequiredError"] = "UiRequiredError";
    /**
     * Token is not within its valid time range error.
     */
    ErrorCode["TokenExpiredError"] = "TokenExpiredError";
    /**
     * Call service (AAD or simple authentication server) failed.
     */
    ErrorCode["ServiceError"] = "ServiceError";
    /**
     * Operation failed.
     */
    ErrorCode["FailedOperation"] = "FailedOperation";
    /**
     * Invalid response error.
     */
    ErrorCode["InvalidResponse"] = "InvalidResponse";
    /**
     * Identity type error.
     */
    ErrorCode["IdentityTypeNotSupported"] = "IdentityTypeNotSupported";
    /**
     * Authentication info already exists error.
     */
    ErrorCode["AuthorizationInfoAlreadyExists"] = "AuthorizationInfoAlreadyExists";
})(ErrorCode || (ErrorCode = {}));
/**
 * @internal
 */
class ErrorMessage {
}
// InvalidConfiguration Error
ErrorMessage.InvalidConfiguration = "{0} in configuration is invalid: {1}.";
ErrorMessage.ConfigurationNotExists = "Configuration does not exist. {0}";
ErrorMessage.ResourceConfigurationNotExists = "{0} resource configuration does not exist.";
ErrorMessage.MissingResourceConfiguration = "Missing resource configuration with type: {0}, name: {1}.";
ErrorMessage.AuthenticationConfigurationNotExists = "Authentication configuration does not exist.";
// RuntimeNotSupported Error
ErrorMessage.BrowserRuntimeNotSupported = "{0} is not supported in browser.";
ErrorMessage.NodejsRuntimeNotSupported = "{0} is not supported in Node.";
// Internal Error
ErrorMessage.FailToAcquireTokenOnBehalfOfUser = "Failed to acquire access token on behalf of user: {0}";
// ChannelNotSupported Error
ErrorMessage.OnlyMSTeamsChannelSupported = "{0} is only supported in MS Teams Channel";
// IdentityTypeNotSupported Error
ErrorMessage.IdentityTypeNotSupported = "{0} identity is not supported in {1}";
// AuthorizationInfoError
ErrorMessage.AuthorizationHeaderAlreadyExists = "Authorization header already exists!";
ErrorMessage.BasicCredentialAlreadyExists = "Basic credential already exists!";
// InvalidParameter Error
ErrorMessage.EmptyParameter = "Parameter {0} is empty";
ErrorMessage.DuplicateHttpsOptionProperty = "Axios HTTPS agent already defined value for property {0}";
ErrorMessage.DuplicateApiKeyInHeader = "The request already defined api key in request header with name {0}.";
ErrorMessage.DuplicateApiKeyInQueryParam = "The request already defined api key in query parameter with name {0}.";
/**
 * Error class with code and message thrown by the SDK.
 */
class ErrorWithCode extends Error {
    /**
     * Constructor of ErrorWithCode.
     *
     * @param {string} message - error message.
     * @param {ErrorCode} code - error code.
     */
    constructor(message, code) {
        if (!code) {
            super(message);
            return this;
        }
        super(message);
        Object.setPrototypeOf(this, ErrorWithCode.prototype);
        this.name = `${new.target.name}.${code}`;
        this.code = code;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Log level.
 */
var LogLevel;
(function (LogLevel) {
    /**
     * Show verbose, information, warning and error message.
     */
    LogLevel[LogLevel["Verbose"] = 0] = "Verbose";
    /**
     * Show information, warning and error message.
     */
    LogLevel[LogLevel["Info"] = 1] = "Info";
    /**
     * Show warning and error message.
     */
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    /**
     * Show error message.
     */
    LogLevel[LogLevel["Error"] = 3] = "Error";
})(LogLevel || (LogLevel = {}));
/**
 * Update log level helper.
 *
 * @param { LogLevel } level - log level in configuration
 */
function setLogLevel(level) {
    internalLogger.level = level;
}
/**
 * Get log level.
 *
 * @returns Log level
 */
function getLogLevel() {
    return internalLogger.level;
}
class InternalLogger {
    constructor(name, logLevel) {
        this.level = undefined;
        this.defaultLogger = {
            verbose: console.debug,
            info: console.info,
            warn: console.warn,
            error: console.error,
        };
        this.name = name;
        this.level = logLevel;
    }
    error(message) {
        this.log(LogLevel.Error, (x) => x.error, message);
    }
    warn(message) {
        this.log(LogLevel.Warn, (x) => x.warn, message);
    }
    info(message) {
        this.log(LogLevel.Info, (x) => x.info, message);
    }
    verbose(message) {
        this.log(LogLevel.Verbose, (x) => x.verbose, message);
    }
    log(logLevel, logFunction, message) {
        if (message.trim() === "") {
            return;
        }
        const timestamp = new Date().toUTCString();
        let logHeader;
        if (this.name) {
            logHeader = `[${timestamp}] : @microsoft/teamsfx - ${this.name} : ${LogLevel[logLevel]} - `;
        }
        else {
            logHeader = `[${timestamp}] : @microsoft/teamsfx : ${LogLevel[logLevel]} - `;
        }
        const logMessage = `${logHeader}${message}`;
        if (this.level !== undefined && this.level <= logLevel) {
            if (this.customLogger) {
                logFunction(this.customLogger)(logMessage);
            }
            else if (this.customLogFunction) {
                this.customLogFunction(logLevel, logMessage);
            }
            else {
                logFunction(this.defaultLogger)(logMessage);
            }
        }
    }
}
/**
 * Logger instance used internally
 *
 * @internal
 */
const internalLogger = new InternalLogger();
/**
 * Set custom logger. Use the output functions if it's set. Priority is higher than setLogFunction.
 *
 * @param {Logger} logger - custom logger. If it's undefined, custom logger will be cleared.
 *
 * @example
 * ```typescript
 * setLogger({
 *   verbose: console.debug,
 *   info: console.info,
 *   warn: console.warn,
 *   error: console.error,
 * });
 * ```
 */
function setLogger(logger) {
    internalLogger.customLogger = logger;
}
/**
 * Set custom log function. Use the function if it's set. Priority is lower than setLogger.
 *
 * @param {LogFunction} logFunction - custom log function. If it's undefined, custom log function will be cleared.
 *
 * @example
 * ```typescript
 * setLogFunction((level: LogLevel, message: string) => {
 *   if (level === LogLevel.Error) {
 *     console.log(message);
 *   }
 * });
 * ```
 */
function setLogFunction(logFunction) {
    internalLogger.customLogFunction = logFunction;
}

// Copyright (c) Microsoft Corporation.
/**
 * Parse jwt token payload
 *
 * @param token
 *
 * @returns Payload object
 *
 * @internal
 */
function parseJwt(token) {
    try {
        const tokenObj = jwt_decode(token);
        if (!tokenObj || !tokenObj.exp) {
            throw new ErrorWithCode("Decoded token is null or exp claim does not exists.", ErrorCode.InternalError);
        }
        return tokenObj;
    }
    catch (err) {
        const errorMsg = "Parse jwt token failed in node env with error: " + err.message;
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, ErrorCode.InternalError);
    }
}
/**
 * @internal
 */
function getUserInfoFromSsoToken(ssoToken) {
    if (!ssoToken) {
        const errorMsg = "SSO token is undefined.";
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, ErrorCode.InvalidParameter);
    }
    const tokenObject = parseJwt(ssoToken);
    const userInfo = {
        displayName: tokenObject.name,
        objectId: tokenObject.oid,
        preferredUserName: "",
    };
    if (tokenObject.ver === "2.0") {
        userInfo.preferredUserName = tokenObject.preferred_username;
    }
    else if (tokenObject.ver === "1.0") {
        userInfo.preferredUserName = tokenObject.upn;
    }
    return userInfo;
}
/**
 * @internal
 */
function getTenantIdAndLoginHintFromSsoToken(ssoToken) {
    if (!ssoToken) {
        const errorMsg = "SSO token is undefined.";
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, ErrorCode.InvalidParameter);
    }
    const tokenObject = parseJwt(ssoToken);
    const userInfo = {
        tid: tokenObject.tid,
        loginHint: tokenObject.ver === "2.0"
            ? tokenObject.preferred_username
            : tokenObject.upn,
    };
    return userInfo;
}
/**
 * @internal
 */
function parseAccessTokenFromAuthCodeTokenResponse(tokenResponse) {
    try {
        const tokenResponseObject = typeof tokenResponse == "string"
            ? JSON.parse(tokenResponse)
            : tokenResponse;
        if (!tokenResponseObject || !tokenResponseObject.accessToken) {
            const errorMsg = "Get empty access token from Auth Code token response.";
            internalLogger.error(errorMsg);
            throw new Error(errorMsg);
        }
        const token = tokenResponseObject.accessToken;
        const tokenObject = parseJwt(token);
        if (tokenObject.ver !== "1.0" && tokenObject.ver !== "2.0") {
            const errorMsg = "SSO token is not valid with an unknown version: " + tokenObject.ver;
            internalLogger.error(errorMsg);
            throw new Error(errorMsg);
        }
        const accessToken = {
            token: token,
            expiresOnTimestamp: tokenObject.exp * 1000,
        };
        return accessToken;
    }
    catch (error) {
        const errorMsg = "Parse access token failed from Auth Code token response in node env with error: " +
            error.message;
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, ErrorCode.InternalError);
    }
}
/**
 * Format string template with replacements
 *
 * ```typescript
 * const template = "{0} and {1} are fruit. {0} is my favorite one."
 * const formattedStr = formatString(template, "apple", "pear"); // formattedStr: "apple and pear are fruit. apple is my favorite one."
 * ```
 *
 * @param str string template
 * @param replacements replacement string array
 * @returns Formatted string
 *
 * @internal
 */
function formatString(str, ...replacements) {
    const args = replacements;
    return str.replace(/{(\d+)}/g, function (match, number) {
        return typeof args[number] != "undefined" ? args[number] : match;
    });
}
/**
 * @internal
 */
function validateScopesType(value) {
    // string
    if (typeof value === "string" || value instanceof String) {
        return;
    }
    // empty array
    if (Array.isArray(value) && value.length === 0) {
        return;
    }
    // string array
    if (Array.isArray(value) && value.length > 0 && value.every((item) => typeof item === "string")) {
        return;
    }
    const errorMsg = "The type of scopes is not valid, it must be string or string array";
    internalLogger.error(errorMsg);
    throw new ErrorWithCode(errorMsg, ErrorCode.InvalidParameter);
}

// Copyright (c) Microsoft Corporation.
/**
 * Represent Microsoft 365 tenant identity, and it is usually used when user is not involved.
 *
 * @remarks
 * Only works in in server side.
 */
class AppCredential {
    /**
     * Constructor of AppCredential.
     *
     * @remarks
     * Only works in in server side.
     */
    constructor(authConfig) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "AppCredential"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get access token for credential.
     *
     * @remarks
     * Only works in in server side.
     */
    getToken(scopes, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "AppCredential"), ErrorCode.RuntimeNotSupported);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Represent on-behalf-of flow to get user identity, and it is designed to be used in Azure Function or Bot scenarios.
 *
 * @remarks
 * Can only be used in server side.
 */
class OnBehalfOfUserCredential {
    /**
     * Constructor of OnBehalfOfUserCredential
     *
     * @remarks
     * Can Only works in in server side.
     */
    constructor(ssoToken, config) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "OnBehalfOfUserCredential"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get access token from credential.
     * @remarks
     * Can only be used in server side.
     */
    getToken(scopes, options) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "OnBehalfOfUserCredential"), ErrorCode.RuntimeNotSupported);
        });
    }
    /**
     * Get basic user info from SSO token.
     * @remarks
     * Can only be used in server side.
     */
    getUserInfo() {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "OnBehalfOfUserCredential"), ErrorCode.RuntimeNotSupported);
    }
}

// Copyright (c) Microsoft Corporation.
const tokenRefreshTimeSpanInMillisecond = 5 * 60 * 1000;
const loginPageWidth = 600;
const loginPageHeight = 535;
/**
 * Represent Teams current user's identity, and it is used within Teams tab application.
 *
 * @remarks
 * Can only be used within Teams.
 */
class TeamsUserCredential {
    /**
     * Constructor of TeamsUserCredential.
     *
     * @example
     * ```typescript
     * const config = {
     *  authentication: {
     *    initiateLoginEndpoint: "https://localhost:3000/auth-start.html",
     *    clientId: "xxx"
     *   }
     * }
     * // Use default configuration provided by Teams Toolkit
     * const credential = new TeamsUserCredential();
     * // Use a customized configuration
     * const anotherCredential = new TeamsUserCredential(config);
     * ```
     *
     * @param {AuthenticationConfiguration} authConfig - The authentication configuration. Use environment variables if not provided.
     *
     * @throws {@link ErrorCode|InvalidConfiguration} when client id, initiate login endpoint or simple auth endpoint is not found in config.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    constructor(authConfig) {
        internalLogger.info("Create teams user credential");
        this.config = this.loadAndValidateConfig(authConfig);
        this.ssoToken = null;
        this.initialized = false;
    }
    /**
     * Popup login page to get user's access token with specific scopes.
     *
     * @remarks
     * Only works in Teams client APP. User will be redirected to the authorization page to login and consent.
     *
     * @example
     * ```typescript
     * await credential.login(["https://graph.microsoft.com/User.Read"]); // single scope using string array
     * await credential.login("https://graph.microsoft.com/User.Read"); // single scopes using string
     * await credential.login(["https://graph.microsoft.com/User.Read", "Calendars.Read"]); // multiple scopes using string array
     * await credential.login("https://graph.microsoft.com/User.Read Calendars.Read"); // multiple scopes using string
     * ```
     * @param scopes - The list of scopes for which the token will have access, before that, we will request user to consent.
     *
     * @throws {@link ErrorCode|InternalError} when failed to login with unknown error.
     * @throws {@link ErrorCode|ConsentFailed} when user canceled or failed to consent.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    login(scopes) {
        return __awaiter(this, void 0, void 0, function* () {
            validateScopesType(scopes);
            const scopesStr = typeof scopes === "string" ? scopes : scopes.join(" ");
            internalLogger.info(`Popup login page to get user's access token with scopes: ${scopesStr}`);
            if (!this.initialized) {
                yield this.init();
            }
            return new Promise((resolve, reject) => {
                microsoftTeams.initialize(() => {
                    microsoftTeams.authentication.authenticate({
                        url: `${this.config.initiateLoginEndpoint}?clientId=${this.config.clientId}&scope=${encodeURI(scopesStr)}&loginHint=${this.loginHint}`,
                        width: loginPageWidth,
                        height: loginPageHeight,
                        successCallback: (result) => __awaiter(this, void 0, void 0, function* () {
                            if (!result) {
                                const errorMsg = "Get empty authentication result from MSAL";
                                internalLogger.error(errorMsg);
                                reject(new ErrorWithCode(errorMsg, ErrorCode.InternalError));
                                return;
                            }
                            let resultJson = {};
                            try {
                                resultJson = typeof result == "string" ? JSON.parse(result) : result;
                            }
                            catch (error) {
                                // If can not parse result as Json, will throw error.
                                const failedToParseResult = "Failed to parse response to Json.";
                                internalLogger.error(failedToParseResult);
                                reject(new ErrorWithCode(failedToParseResult, ErrorCode.InvalidResponse));
                            }
                            // If code exists in result, user may using previous auth-start and auth-end page.
                            if (resultJson.code) {
                                const helpLink = "https://aka.ms/teamsfx-auth-code-flow";
                                const usingPreviousAuthPage = "Found auth code in response. Auth code is not support for current version of SDK. " +
                                    `Please refer to the help link for how to fix the issue: ${helpLink}.`;
                                internalLogger.error(usingPreviousAuthPage);
                                reject(new ErrorWithCode(usingPreviousAuthPage, ErrorCode.InvalidResponse));
                            }
                            // If sessionStorage exists in result, set the values in current session storage.
                            if (resultJson.sessionStorage) {
                                this.setSessionStorage(resultJson.sessionStorage);
                            }
                            resolve();
                        }),
                        failureCallback: (reason) => {
                            const errorMsg = `Consent failed for the scope ${scopesStr} with error: ${reason}`;
                            internalLogger.error(errorMsg);
                            reject(new ErrorWithCode(errorMsg, ErrorCode.ConsentFailed));
                        },
                    });
                });
            });
        });
    }
    /**
     * Get access token from credential.
     *
     * Important: Access tokens are stored in sessionStorage, read more here: https://aka.ms/teamsfx-session-storage-notice
     *
     * @example
     * ```typescript
     * await credential.getToken([]) // Get SSO token using empty string array
     * await credential.getToken("") // Get SSO token using empty string
     * await credential.getToken([".default"]) // Get Graph access token with default scope using string array
     * await credential.getToken(".default") // Get Graph access token with default scope using string
     * await credential.getToken(["User.Read"]) // Get Graph access token for single scope using string array
     * await credential.getToken("User.Read") // Get Graph access token for single scope using string
     * await credential.getToken(["User.Read", "Application.Read.All"]) // Get Graph access token for multiple scopes using string array
     * await credential.getToken("User.Read Application.Read.All") // Get Graph access token for multiple scopes using space-separated string
     * await credential.getToken("https://graph.microsoft.com/User.Read") // Get Graph access token with full resource URI
     * await credential.getToken(["https://outlook.office.com/Mail.Read"]) // Get Outlook access token
     * ```
     *
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     * @param {GetTokenOptions} options - The options used to configure any requests this TokenCredential implementation might make.
     *
     * @throws {@link ErrorCode|InternalError} when failed to get access token with unknown error.
     * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     *
     * @returns User access token of defined scopes.
     * If scopes is empty string or array, it returns SSO token.
     * If scopes is non-empty, it returns access token for target scope.
     * Throw error if get access token failed.
     */
    getToken(scopes, options) {
        return __awaiter(this, void 0, void 0, function* () {
            validateScopesType(scopes);
            const ssoToken = yield this.getSSOToken();
            const scopeStr = typeof scopes === "string" ? scopes : scopes.join(" ");
            if (scopeStr === "") {
                internalLogger.info("Get SSO token");
                return ssoToken;
            }
            else {
                internalLogger.info("Get access token with scopes: " + scopeStr);
                if (!this.initialized) {
                    yield this.init();
                }
                let tokenResponse;
                const scopesArray = typeof scopes === "string" ? scopes.split(" ") : scopes;
                const domain = window.location.origin;
                // First try to get Access Token from cache.
                try {
                    const account = this.msalInstance.getAccountByUsername(this.loginHint);
                    const scopesRequestForAcquireTokenSilent = {
                        scopes: scopesArray,
                        account: account !== null && account !== void 0 ? account : undefined,
                        redirectUri: `${domain}/blank-auth-end.html`,
                    };
                    tokenResponse = yield this.msalInstance.acquireTokenSilent(scopesRequestForAcquireTokenSilent);
                }
                catch (error) {
                    const acquireTokenSilentFailedMessage = `Failed to call acquireTokenSilent. Reason: ${error === null || error === void 0 ? void 0 : error.message}. `;
                    internalLogger.verbose(acquireTokenSilentFailedMessage);
                }
                if (!tokenResponse) {
                    // If fail to get Access Token from cache, try to get Access token by silent login.
                    try {
                        const scopesRequestForSsoSilent = {
                            scopes: scopesArray,
                            loginHint: this.loginHint,
                            redirectUri: `${domain}/blank-auth-end.html`,
                        };
                        tokenResponse = yield this.msalInstance.ssoSilent(scopesRequestForSsoSilent);
                    }
                    catch (error) {
                        const ssoSilentFailedMessage = `Failed to call ssoSilent. Reason: ${error === null || error === void 0 ? void 0 : error.message}. `;
                        internalLogger.verbose(ssoSilentFailedMessage);
                    }
                }
                if (!tokenResponse) {
                    const errorMsg = `Failed to get access token cache silently, please login first: you need login first before get access token.`;
                    internalLogger.error(errorMsg);
                    throw new ErrorWithCode(errorMsg, ErrorCode.UiRequiredError);
                }
                const accessToken = parseAccessTokenFromAuthCodeTokenResponse(tokenResponse);
                return accessToken;
            }
        });
    }
    /**
     * Get basic user info from SSO token
     *
     * @example
     * ```typescript
     * const currentUser = await credential.getUserInfo();
     * ```
     *
     * @throws {@link ErrorCode|InternalError} when SSO token from Teams client is not valid.
     * @throws {@link ErrorCode|InvalidParameter} when SSO token from Teams client is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     *
     * @returns Basic user info with user displayName, objectId and preferredUserName.
     */
    getUserInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            internalLogger.info("Get basic user info from SSO token");
            const ssoToken = yield this.getSSOToken();
            return getUserInfoFromSsoToken(ssoToken.token);
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const ssoToken = yield this.getSSOToken();
            const info = getTenantIdAndLoginHintFromSsoToken(ssoToken.token);
            this.loginHint = info.loginHint;
            this.tid = info.tid;
            const msalConfig = {
                auth: {
                    clientId: this.config.clientId,
                    authority: `https://login.microsoftonline.com/${this.tid}`,
                },
                cache: {
                    cacheLocation: "sessionStorage",
                },
            };
            this.msalInstance = new PublicClientApplication(msalConfig);
            this.initialized = true;
        });
    }
    /**
     * Get SSO token using teams SDK
     * It will try to get SSO token from memory first, if SSO token doesn't exist or about to expired, then it will using teams SDK to get SSO token
     * @returns SSO token
     */
    getSSOToken() {
        return new Promise((resolve, reject) => {
            if (this.ssoToken) {
                if (this.ssoToken.expiresOnTimestamp - Date.now() > tokenRefreshTimeSpanInMillisecond) {
                    internalLogger.verbose("Get SSO token from memory cache");
                    resolve(this.ssoToken);
                    return;
                }
            }
            if (this.checkInTeams()) {
                microsoftTeams.initialize(() => {
                    microsoftTeams.authentication.getAuthToken({
                        successCallback: (token) => {
                            if (!token) {
                                const errorMsg = "Get empty SSO token from Teams";
                                internalLogger.error(errorMsg);
                                reject(new ErrorWithCode(errorMsg, ErrorCode.InternalError));
                                return;
                            }
                            const tokenObject = parseJwt(token);
                            if (tokenObject.ver !== "1.0" && tokenObject.ver !== "2.0") {
                                const errorMsg = "SSO token is not valid with an unknown version: " + tokenObject.ver;
                                internalLogger.error(errorMsg);
                                reject(new ErrorWithCode(errorMsg, ErrorCode.InternalError));
                                return;
                            }
                            const ssoToken = {
                                token,
                                expiresOnTimestamp: tokenObject.exp * 1000,
                            };
                            this.ssoToken = ssoToken;
                            resolve(ssoToken);
                        },
                        failureCallback: (errMessage) => {
                            const errorMsg = "Get SSO token failed with error: " + errMessage;
                            internalLogger.error(errorMsg);
                            reject(new ErrorWithCode(errorMsg, ErrorCode.InternalError));
                        },
                        resources: [],
                    });
                });
            }
            else {
                const errorMsg = "Initialize teams sdk failed due to not running inside Teams";
                internalLogger.error(errorMsg);
                reject(new ErrorWithCode(errorMsg, ErrorCode.InternalError));
            }
        });
    }
    /**
     * Load and validate authentication configuration
     *
     * @param {AuthenticationConfiguration?} config - The authentication configuration. Use environment variables if not provided.
     *
     * @returns Authentication configuration
     */
    loadAndValidateConfig(config) {
        internalLogger.verbose("Validate authentication configuration");
        if (config.initiateLoginEndpoint && config.clientId) {
            return config;
        }
        const missingValues = [];
        if (!config.initiateLoginEndpoint) {
            missingValues.push("initiateLoginEndpoint");
        }
        if (!config.clientId) {
            missingValues.push("clientId");
        }
        const errorMsg = formatString(ErrorMessage.InvalidConfiguration, missingValues.join(", "), "undefined");
        internalLogger.error(errorMsg);
        throw new ErrorWithCode(errorMsg, ErrorCode.InvalidConfiguration);
    }
    setSessionStorage(sessionStorageValues) {
        try {
            const sessionStorageKeys = Object.keys(sessionStorageValues);
            sessionStorageKeys.forEach((key) => {
                sessionStorage.setItem(key, sessionStorageValues[key]);
            });
        }
        catch (error) {
            // Values in result.sessionStorage can not be set into session storage.
            // Throw error since this may block user.
            const errorMessage = `Failed to set values in session storage. Error: ${error.message}`;
            internalLogger.error(errorMessage);
            throw new ErrorWithCode(errorMessage, ErrorCode.InternalError);
        }
    }
    // Come from here: https://github.com/wictorwilen/msteams-react-base-component/blob/master/src/useTeams.ts
    checkInTeams() {
        if ((window.parent === window.self && window.nativeInterface) ||
            window.navigator.userAgent.includes("Teams/") ||
            window.name === "embedded-page-container" ||
            window.name === "extension-tab-frame") {
            return true;
        }
        return false;
    }
}

// Copyright (c) Microsoft Corporation.
const defaultScope = "https://graph.microsoft.com/.default";
/**
 * Microsoft Graph auth provider for Teams Framework
 */
class MsGraphAuthProvider {
    /**
     * Constructor of MsGraphAuthProvider.
     *
     * @param {TeamsFx} teamsfx - Used to provide configuration and auth.
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     *
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     *
     * @returns An instance of MsGraphAuthProvider.
     */
    constructor(teamsfx, scopes) {
        this.teamsfx = teamsfx;
        let scopesStr = defaultScope;
        if (scopes) {
            validateScopesType(scopes);
            scopesStr = typeof scopes === "string" ? scopes : scopes.join(" ");
            if (scopesStr === "") {
                scopesStr = defaultScope;
            }
        }
        internalLogger.info(`Create Microsoft Graph Authentication Provider with scopes: '${scopesStr}'`);
        this.scopes = scopesStr;
    }
    /**
     * Get access token for Microsoft Graph API requests.
     *
     * @throws {@link ErrorCode|InternalError} when get access token failed due to empty token or unknown other problems.
     * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
     * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
     * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth or AAD server.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     *
     * @returns Access token from the credential.
     *
     */
    getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            internalLogger.info(`Get Graph Access token with scopes: '${this.scopes}'`);
            const accessToken = yield this.teamsfx.getCredential().getToken(this.scopes);
            return new Promise((resolve, reject) => {
                if (accessToken) {
                    resolve(accessToken.token);
                }
                else {
                    const errorMsg = "Graph access token is undefined or empty";
                    internalLogger.error(errorMsg);
                    reject(new ErrorWithCode(errorMsg, ErrorCode.InternalError));
                }
            });
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Get Microsoft graph client.
 *
 * @example
 * Get Microsoft graph client by TokenCredential
 * ```typescript
 * // Sso token example (Azure Function)
 * const ssoToken = "YOUR_TOKEN_STRING";
 * const options = {"AAD_APP_ID", "AAD_APP_SECRET"};
 * const credential = new OnBehalfOfAADUserCredential(ssoToken, options);
 * const graphClient = await createMicrosoftGraphClient(credential);
 * const profile = await graphClient.api("/me").get();
 *
 * // TeamsBotSsoPrompt example (Bot Application)
 * const requiredScopes = ["User.Read"];
 * const config: Configuration = {
 *    loginUrl: loginUrl,
 *    clientId: clientId,
 *    clientSecret: clientSecret,
 *    tenantId: tenantId
 * };
 * const prompt = new TeamsBotSsoPrompt(dialogId, {
 *    config: config
 *    scopes: '["User.Read"],
 * });
 * this.addDialog(prompt);
 *
 * const oboCredential = new OnBehalfOfAADUserCredential(
 *  getUserId(dialogContext),
 *  {
 *    clientId: "AAD_APP_ID",
 *    clientSecret: "AAD_APP_SECRET"
 *  });
 * try {
 *    const graphClient = await createMicrosoftGraphClient(credential);
 *    const profile = await graphClient.api("/me").get();
 * } catch (e) {
 *    dialogContext.beginDialog(dialogId);
 *    return Dialog.endOfTurn();
 * }
 * ```
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth.
 * @param scopes - The array of Microsoft Token scope of access. Default value is `[.default]`.
 *
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 *
 * @returns Graph client with specified scopes.
 */
function createMicrosoftGraphClient(teamsfx, scopes) {
    internalLogger.info("Create Microsoft Graph Client");
    const authProvider = new MsGraphAuthProvider(teamsfx, scopes);
    const graphClient = Client.initWithMiddleware({
        authProvider,
    });
    return graphClient;
}

// Copyright (c) Microsoft Corporation.
/**
 * Generate connection configuration consumed by tedious.
 * @remarks
 * Only works in in server side.
 */
function getTediousConnectionConfig(teamsfx, databaseName) {
    return __awaiter(this, void 0, void 0, function* () {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "DefaultTediousConnectionConfiguration"), ErrorCode.RuntimeNotSupported);
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a new prompt that leverage Teams Single Sign On (SSO) support for bot to automatically sign in user and
 * help receive oauth token, asks the user to consent if needed.
 *
 * @remarks
 * The prompt will attempt to retrieve the users current token of the desired scopes and store it in
 * the token store.
 *
 * User will be automatically signed in leveraging Teams support of Bot Single Sign On(SSO):
 * https://docs.microsoft.com/en-us/microsoftteams/platform/bots/how-to/authentication/auth-aad-sso-bots
 *
 * @example
 * When used with your bots `DialogSet` you can simply add a new instance of the prompt as a named
 * dialog using `DialogSet.add()`. You can then start the prompt from a waterfall step using either
 * `DialogContext.beginDialog()` or `DialogContext.prompt()`. The user will be prompted to sign in as
 * needed and their access token will be passed as an argument to the callers next waterfall step:
 *
 * ```JavaScript
 * const { ConversationState, MemoryStorage } = require('botbuilder');
 * const { DialogSet, WaterfallDialog } = require('botbuilder-dialogs');
 * const { TeamsBotSsoPrompt } = require('@microsoft/teamsfx');
 *
 * const convoState = new ConversationState(new MemoryStorage());
 * const dialogState = convoState.createProperty('dialogState');
 * const dialogs = new DialogSet(dialogState);
 *
 * dialogs.add(new TeamsBotSsoPrompt('TeamsBotSsoPrompt', {
 *    scopes: ["User.Read"],
 * }));
 *
 * dialogs.add(new WaterfallDialog('taskNeedingLogin', [
 *      async (step) => {
 *          return await step.beginDialog('TeamsBotSsoPrompt');
 *      },
 *      async (step) => {
 *          const token = step.result;
 *          if (token) {
 *
 *              // ... continue with task needing access token ...
 *
 *          } else {
 *              await step.context.sendActivity(`Sorry... We couldn't log you in. Try again later.`);
 *              return await step.endDialog();
 *          }
 *      }
 * ]));
 * ```
 */
class TeamsBotSsoPrompt {
    /**
     * Constructor of TeamsBotSsoPrompt.
     *
     * @param dialogId Unique ID of the dialog within its parent `DialogSet` or `ComponentDialog`.
     * @param settings Settings used to configure the prompt.
     *
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(teamsfx, dialogId, settings) {
        this.teamsfx = teamsfx;
        this.settings = settings;
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotSsoPrompt"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Called when a prompt dialog is pushed onto the dialog stack and is being activated.
     * @remarks
     * If the task is successful, the result indicates whether the prompt is still
     * active after the turn has been processed by the prompt.
     *
     * @param dc The DialogContext for the current turn of the conversation.
     *
     * @throws {@link ErrorCode|InvalidParameter} when timeout property in teams bot sso prompt settings is not number or is not positive.
     * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns A `Promise` representing the asynchronous operation.
     */
    beginDialog(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotSsoPrompt"), ErrorCode.RuntimeNotSupported);
        });
    }
    /**
     * Called when a prompt dialog is the active dialog and the user replied with a new activity.
     *
     * @remarks
     * If the task is successful, the result indicates whether the dialog is still
     * active after the turn has been processed by the dialog.
     * The prompt generally continues to receive the user's replies until it accepts the
     * user's reply as valid input for the prompt.
     *
     * @param dc The DialogContext for the current turn of the conversation.
     *
     * @returns A `Promise` representing the asynchronous operation.
     *
     * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    continueDialog(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotSsoPrompt"), ErrorCode.RuntimeNotSupported);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Initializes new Axios instance with specific auth provider
 *
 * @param apiEndpoint - Base url of the API
 * @param authProvider - Auth provider that injects authentication info to each request
 * @returns axios instance configured with specfic auth provider
 *
 * @example
 * ```typescript
 * const client = createApiClient("https://my-api-endpoint-base-url", new BasicAuthProvider("xxx","xxx"));
 * ```
 */
function createApiClient(apiEndpoint, authProvider) {
    // Add a request interceptor
    const instance = axios.create({
        baseURL: apiEndpoint,
    });
    instance.interceptors.request.use(function (config) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield authProvider.AddAuthenticationInfo(config);
        });
    });
    return instance;
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Bearer Token authentication
 */
class BearerTokenAuthProvider {
    /**
     * @param { () => Promise<string> } getToken - Function that returns the content of bearer token used in http request
     */
    constructor(getToken) {
        this.getToken = getToken;
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header already exists in request configuration.
     */
    AddAuthenticationInfo(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getToken();
            if (!config.headers) {
                config.headers = {};
            }
            if (config.headers["Authorization"]) {
                throw new ErrorWithCode(ErrorMessage.AuthorizationHeaderAlreadyExists, ErrorCode.AuthorizationInfoAlreadyExists);
            }
            config.headers["Authorization"] = `Bearer ${token}`;
            return config;
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Basic authentication
 */
class BasicAuthProvider {
    /**
     *
     * @param { string } userName - Username used in basic auth
     * @param { string } password - Password used in basic auth
     *
     * @throws {@link ErrorCode|InvalidParameter} - when username or password is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(userName, password) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "BasicAuthProvider"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header or auth property already exists in request configuration.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "BasicAuthProvider"), ErrorCode.RuntimeNotSupported);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles API Key authentication
 */
class ApiKeyProvider {
    /**
     *
     * @param { string } keyName - The name of request header or query parameter that specifies API Key
     * @param { string } keyValue - The value of API Key
     * @param { ApiKeyLocation } keyLocation - The location of API Key: request header or query parameter.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when key name or key value is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(keyName, keyValue, keyLocation) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "ApiKeyProvider"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when API key already exists in request header or url query parameter.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "ApiKeyProvider"), ErrorCode.RuntimeNotSupported);
        });
    }
}
/**
 * Define available location for API Key location
 */
var ApiKeyLocation;
(function (ApiKeyLocation) {
    /**
     * The API Key is placed in request header
     */
    ApiKeyLocation[ApiKeyLocation["Header"] = 0] = "Header";
    /**
     * The API Key is placed in query parameter
     */
    ApiKeyLocation[ApiKeyLocation["QueryParams"] = 1] = "QueryParams";
})(ApiKeyLocation || (ApiKeyLocation = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Provider that handles Certificate authentication
 */
class CertificateAuthProvider {
    /**
     *
     * @param { SecureContextOptions } certOption - information about the cert used in http requests
     */
    constructor(certOption) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CertificateAuthProvider"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Adds authentication info to http requests.
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when custom httpsAgent in the request has duplicate properties with certOption provided in constructor.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CertificateAuthProvider"), ErrorCode.RuntimeNotSupported);
        });
    }
}
/**
 * Helper to create SecureContextOptions from PEM format cert
 *
 * @param { string | Buffer } cert - The cert chain in PEM format
 * @param { string | Buffer } key - The private key for the cert chain
 * @param { {passphrase?: string; ca?: string | Buffer} } options - Optional settings when create the cert options.
 *
 * @returns Instance of SecureContextOptions
 *
 * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
 *
 */
function createPemCertOption(cert, key, options) {
    throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "createPemCertOption"), ErrorCode.RuntimeNotSupported);
}
/**
 * Helper to create SecureContextOptions from PFX format cert
 *
 * @param { string | Buffer } pfx - The content of .pfx file
 * @param { {passphrase?: string} } options - Optional settings when create the cert options.
 *
 * @returns Instance of SecureContextOptions
 *
 * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
 *
 */
function createPfxCertOption(pfx, options) {
    throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "createPfxCertOption"), ErrorCode.RuntimeNotSupported);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Identity type to use in authentication.
 */
var IdentityType;
(function (IdentityType) {
    /**
     * Represents the current user of Teams.
     */
    IdentityType["User"] = "User";
    /**
     * Represents the application itself.
     */
    IdentityType["App"] = "Application";
})(IdentityType || (IdentityType = {}));

// Copyright (c) Microsoft Corporation.
/**
 * A class providing credential and configuration.
 */
class TeamsFx {
    constructor(identityType, customConfig) {
        this.identityType = identityType !== null && identityType !== void 0 ? identityType : IdentityType.User;
        if (this.identityType !== IdentityType.User) {
            const errorMsg = formatString(ErrorMessage.IdentityTypeNotSupported, this.identityType.toString(), "TeamsFx");
            internalLogger.error(errorMsg);
            throw new ErrorWithCode(errorMsg, ErrorCode.IdentityTypeNotSupported);
        }
        this.configuration = new Map();
        this.loadFromEnv();
        if (customConfig) {
            for (const key of Object.keys(customConfig)) {
                const value = customConfig[key];
                if (value) {
                    this.configuration.set(key, value);
                }
            }
        }
        if (this.configuration.size === 0) {
            internalLogger.warn("No configuration is loaded, please pass required configs to TeamsFx constructor");
        }
    }
    loadFromEnv() {
        if (window && window.__env__) {
            // testing purpose
            const env = window.__env__;
            this.configuration.set("authorityHost", env.REACT_APP_AUTHORITY_HOST);
            this.configuration.set("tenantId", env.REACT_APP_TENANT_ID);
            this.configuration.set("clientId", env.REACT_APP_CLIENT_ID);
            this.configuration.set("initiateLoginEndpoint", env.REACT_APP_START_LOGIN_PAGE_URL);
            this.configuration.set("applicationIdUri", env.M365_APPLICATION_ID_URI);
            this.configuration.set("apiEndpoint", env.REACT_APP_FUNC_ENDPOINT);
            this.configuration.set("apiName", env.REACT_APP_FUNC_NAME);
        }
        else {
            // TODO: support common environment variable name
            try {
                this.configuration.set("authorityHost", process.env.REACT_APP_AUTHORITY_HOST);
                this.configuration.set("tenantId", process.env.REACT_APP_TENANT_ID);
                this.configuration.set("clientId", process.env.REACT_APP_CLIENT_ID);
                this.configuration.set("initiateLoginEndpoint", process.env.REACT_APP_START_LOGIN_PAGE_URL);
                this.configuration.set("applicationIdUri", process.env.M365_APPLICATION_ID_URI);
                this.configuration.set("apiEndpoint", process.env.REACT_APP_FUNC_ENDPOINT);
                this.configuration.set("apiName", process.env.REACT_APP_FUNC_NAME);
            }
            catch (_) {
                internalLogger.warn("Cannot read process.env, please use webpack if you want to use environment variables.");
                return;
            }
        }
    }
    getIdentityType() {
        return this.identityType;
    }
    getCredential() {
        if (!this.teamsUserCredential) {
            this.teamsUserCredential = new TeamsUserCredential(Object.fromEntries(this.configuration));
        }
        return this.teamsUserCredential;
    }
    getUserInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getCredential().getUserInfo();
        });
    }
    login(scopes) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getCredential().login(scopes);
        });
    }
    setSsoToken(ssoToken) {
        return this;
    }
    getConfig(key) {
        const value = this.configuration.get(key);
        if (!value) {
            throw new Error();
        }
        return value;
    }
    hasConfig(key) {
        const value = this.configuration.get(key);
        return !!value;
    }
    getConfigs() {
        const config = {};
        for (const key of this.configuration.keys()) {
            const value = this.configuration.get(key);
            if (value) {
                config[key] = value;
            }
        }
        return config;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provide utilities for bot conversation, including:
 *   - handle command and response.
 *   - send notification to varies targets (e.g., member, group, channel).
 *
 * @remarks
 * Only work on server side.
 */
class ConversationBot {
    /**
     * Creates new instance of the `ConversationBot`.
     *
     * @param options - initialize options
     *
     * @remarks
     * Only work on server side.
     */
    constructor(options) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "ConversationBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * The request handler to integrate with web request.
     *
     * @param req - an Express or Restify style request object.
     * @param res - an Express or Restify style response object.
     * @param logic - the additional function to handle bot context.
     *
     * @remarks
     * Only work on server side.
     */
    requestHandler(req, res, logic) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "ConversationBot"), ErrorCode.RuntimeNotSupported);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Send a plain text message to a notification target.
 *
 * @remarks
 * Only work on server side.
 *
 * @param target - the notification target.
 * @param text - the plain text message.
 * @returns A `Promise` representing the asynchronous operation.
 */
function sendMessage(target, text) {
    throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "sendMessage"), ErrorCode.RuntimeNotSupported);
}
/**
 * Send an adaptive card message to a notification target.
 *
 * @remarks
 * Only work on server side.
 *
 * @param target - the notification target.
 * @param card - the adaptive card raw JSON.
 * @returns A `Promise` representing the asynchronous operation.
 */
function sendAdaptiveCard(target, card) {
    throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "sendAdaptiveCard"), ErrorCode.RuntimeNotSupported);
}
/**
 * A {@link NotificationTarget} that represents a team channel.
 *
 * @remarks
 * Only work on server side.
 *
 * It's recommended to get channels from {@link TeamsBotInstallation.channels()}.
 */
class Channel {
    /**
     * Constructor.
     *
     * @remarks
     * Only work on server side.
     *
     * It's recommended to get channels from {@link TeamsBotInstallation.channels()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this channel is created from.
     * @param info - Detailed channel information.
     */
    constructor(parent, info) {
        /**
         * Notification target type. For channel it's always "Channel".
         *
         * @remarks
         * Only work on server side.
         */
        this.type = "Channel";
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Channel"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send a plain text message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param text - the plain text message.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendMessage(text) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Channel"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send an adaptive card message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param card - the adaptive card raw JSON.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendAdaptiveCard(card) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Channel"), ErrorCode.RuntimeNotSupported);
        });
    }
}
/**
 * A {@link NotificationTarget} that represents a team member.
 *
 * @remarks
 * Only work on server side.
 *
 * It's recommended to get members from {@link TeamsBotInstallation.members()}.
 */
class Member {
    /**
     * Constructor.
     *
     * @remarks
     * Only work on server side.
     *
     * It's recommended to get members from {@link TeamsBotInstallation.members()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this member is created from.
     * @param account - Detailed member account information.
     */
    constructor(parent, account) {
        /**
         * Notification target type. For member it's always "Person".
         *
         * @remarks
         * Only work on server side.
         */
        this.type = "Person";
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Member"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send a plain text message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param text - the plain text message.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendMessage(text) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Member"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send an adaptive card message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param card - the adaptive card raw JSON.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendAdaptiveCard(card) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "Member"), ErrorCode.RuntimeNotSupported);
        });
    }
}
/**
 * A {@link NotificationTarget} that represents a bot installation. Teams Bot could be installed into
 * - Personal chat
 * - Group chat
 * - Team (by default the `General` channel)
 *
 * @remarks
 * Only work on server side.
 *
 * It's recommended to get bot installations from {@link ConversationBot.installations()}.
 */
class TeamsBotInstallation {
    /**
     * Constructor
     *
     * @remarks
     * Only work on server side.
     *
     * It's recommended to get bot installations from {@link ConversationBot.installations()}, instead of using this constructor.
     *
     * @param adapter - the bound `BotFrameworkAdapter`.
     * @param conversationReference - the bound `ConversationReference`.
     */
    constructor(adapter, conversationReference) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send a plain text message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param text - the plain text message.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendMessage(text) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Send an adaptive card message.
     *
     * @remarks
     * Only work on server side.
     *
     * @param card - the adaptive card raw JSON.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendAdaptiveCard(card) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get channels from this bot installation.
     *
     * @remarks
     * Only work on server side.
     *
     * @returns an array of channels if bot is installed into a team, otherwise returns an empty array.
     */
    channels() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
        });
    }
    /**
     * Get members from this bot installation.
     *
     * @remarks
     * Only work on server side.
     *
     * @returns an array of members from where the bot is installed.
     */
    members() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "TeamsBotInstallation"), ErrorCode.RuntimeNotSupported);
        });
    }
}
/**
 * Provide static utilities for bot notification.
 *
 * @remarks
 * Only work on server side.
 *
 * @example
 * Here's an example on how to send notification via Teams Bot.
 * ```typescript
 * // initialize (it's recommended to be called before handling any bot message)
 * const notificationBot = new NotificationBot(adapter);
 *
 * // get all bot installations and send message
 * for (const target of await notificationBot.installations()) {
 *   await target.sendMessage("Hello Notification");
 * }
 *
 * // alternative - send message to all members
 * for (const target of await notificationBot.installations()) {
 *   for (const member of await target.members()) {
 *     await member.sendMessage("Hello Notification");
 *   }
 * }
 * ```
 */
class NotificationBot {
    /**
     * constructor of the notification bot.
     *
     * @remarks
     * Only work on server side.
     *
     * To ensure accuracy, it's recommended to initialize before handling any message.
     *
     * @param adapter - the bound `BotFrameworkAdapter`
     * @param options - initialize options
     */
    constructor(adapter, options) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Get all targets where the bot is installed.
     *
     * @remarks
     * Only work on server side.
     *
     * The result is retrieving from the persisted storage.
     *
     * @returns - an array of {@link TeamsBotInstallation}.
     */
    static installations() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "NotificationBot"), ErrorCode.RuntimeNotSupported);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A command bot for receiving commands and sending responses in Teams.
 *
 * @remarks
 * Only work on server side.
 */
class CommandBot {
    /**
     * Creates a new instance of the `CommandBot`.
     *
     * @param adapter The bound `BotFrameworkAdapter`.
     * @param commands The commands to registered with the command bot. Each command should implement the interface {@link TeamsFxBotCommandHandler} so that it can be correctly handled by this command bot.
     */
    constructor(adapter, commands) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Registers a command into the command bot.
     *
     * @param command The command to registered.
     *
     * @remarks
     * Only work on server side.
     */
    registerCommand(command) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandBot"), ErrorCode.RuntimeNotSupported);
    }
    /**
     * Registers commands into the command bot.
     *
     * @param commands The command to registered.
     *
     * @remarks
     * Only work on server side.
     */
    registerCommands(commands) {
        throw new ErrorWithCode(formatString(ErrorMessage.BrowserRuntimeNotSupported, "CommandnBot"), ErrorCode.RuntimeNotSupported);
    }
}

export { ApiKeyLocation, ApiKeyProvider, AppCredential, BasicAuthProvider, BearerTokenAuthProvider, CertificateAuthProvider, Channel, CommandBot, ConversationBot, ErrorCode, ErrorWithCode, IdentityType, LogLevel, Member, MsGraphAuthProvider, NotificationBot, OnBehalfOfUserCredential, TeamsBotInstallation, TeamsBotSsoPrompt, TeamsFx, TeamsUserCredential, createApiClient, createMicrosoftGraphClient, createPemCertOption, createPfxCertOption, getLogLevel, getTediousConnectionConfig, sendAdaptiveCard, sendMessage, setLogFunction, setLogLevel, setLogger };
//# sourceMappingURL=index.esm5.js.map
