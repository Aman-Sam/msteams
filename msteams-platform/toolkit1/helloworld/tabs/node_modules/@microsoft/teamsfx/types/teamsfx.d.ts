/// <reference types="node" />

import { AccessToken } from '@azure/identity';
import { Activity } from 'botbuilder-core';
import { Activity as Activity_2 } from 'botbuilder';
import { Attachment } from 'botbuilder';
import { AuthenticationProvider } from '@microsoft/microsoft-graph-client';
import { AxiosInstance } from 'axios';
import { AxiosRequestConfig } from 'axios';
import { BotFrameworkAdapter } from 'botbuilder';
import { CardAction } from 'botbuilder';
import { CardImage } from 'botbuilder';
import { ChannelInfo } from 'botbuilder';
import { Client } from '@microsoft/microsoft-graph-client';
import { ConnectionConfig } from 'tedious';
import { ConversationReference } from 'botbuilder';
import { Dialog } from 'botbuilder-dialogs';
import { DialogContext } from 'botbuilder-dialogs';
import { DialogTurnResult } from 'botbuilder-dialogs';
import { GetTokenOptions } from '@azure/identity';
import { HeroCard } from 'botbuilder';
import { O365ConnectorCard } from 'botbuilder';
import { ReceiptCard } from 'botbuilder';
import { SecureContextOptions } from 'tls';
import { TeamsChannelAccount } from 'botbuilder';
import { ThumbnailCard } from 'botbuilder';
import { TokenCredential } from '@azure/identity';
import { TokenResponse } from 'botframework-schema';
import { TurnContext } from 'botbuilder-core';
import { TurnContext as TurnContext_2 } from 'botbuilder';
import { WebRequest } from 'botbuilder';
import { WebResponse } from 'botbuilder';

/**
 * Define available location for API Key location
 */
export declare enum ApiKeyLocation {
    /**
     * The API Key is placed in request header
     */
    Header = 0,
    /**
     * The API Key is placed in query parameter
     */
    QueryParams = 1
}

/**
 * Provider that handles API Key authentication
 */
export declare class ApiKeyProvider implements AuthProvider {
    private keyName;
    private keyValue;
    private keyLocation;
    /**
     *
     * @param { string } keyName - The name of request header or query parameter that specifies API Key
     * @param { string } keyValue - The value of API Key
     * @param { ApiKeyLocation } keyLocation - The location of API Key: request header or query parameter.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when key name or key value is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(keyName: string, keyValue: string, keyLocation: ApiKeyLocation);
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when API key already exists in request header or url query parameter.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

/**
 * Represent Microsoft 365 tenant identity, and it is usually used when user is not involved like time-triggered automation job.
 *
 * @example
 * ```typescript
 * loadConfiguration(); // load configuration from environment variables
 * const credential = new AppCredential();
 * ```
 *
 * @remarks
 * Only works in in server side.
 */
export declare class AppCredential implements TokenCredential {
    private readonly msalClient;
    /**
     * Constructor of AppCredential.
     *
     * @remarks
     * Only works in in server side.
     *
     * @param {AuthenticationConfiguration} authConfig - The authentication configuration. Use environment variables if not provided.
     *
     * @throws {@link ErrorCode|InvalidConfiguration} when client id, client secret or tenant id is not found in config.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    constructor(authConfig: AuthenticationConfiguration);
    /**
     * Get access token for credential.
     *
     * @example
     * ```typescript
     * await credential.getToken(["User.Read.All"]) // Get Graph access token for single scope using string array
     * await credential.getToken("User.Read.All") // Get Graph access token for single scope using string
     * await credential.getToken(["User.Read.All", "Calendars.Read"]) // Get Graph access token for multiple scopes using string array
     * await credential.getToken("User.Read.All Calendars.Read") // Get Graph access token for multiple scopes using space-separated string
     * await credential.getToken("https://graph.microsoft.com/User.Read.All") // Get Graph access token with full resource URI
     * await credential.getToken(["https://outlook.office.com/Mail.Read"]) // Get Outlook access token
     * ```
     *
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     * @param {GetTokenOptions} options - The options used to configure any requests this TokenCredential implementation might make.
     *
     * @throws {@link ErrorCode|ServiceError} when get access token with authentication error.
     * @throws {@link ErrorCode|InternalError} when get access token with unknown error.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     *
     * @returns Access token with expected scopes.
     * Throw error if get access token failed.
     */
    getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
    /**
     * Load and validate authentication configuration
     *
     * @param {AuthenticationConfiguration} authConfig - The authentication configuration. Use environment variables if not provided.
     *
     * @returns Authentication configuration
     */
    private loadAndValidateConfig;
}

/**
 * Authentication related configuration.
 */
export declare interface AuthenticationConfiguration {
    /**
     * Hostname of AAD authority. Default value comes from M365_AUTHORITY_HOST environment variable.
     *
     * @readonly
     */
    readonly authorityHost?: string;
    /**
     * AAD tenant id, default value comes from M365_TENANT_ID environment variable.
     *
     * @readonly
     */
    readonly tenantId?: string;
    /**
     * The client (application) ID of an App Registration in the tenant, default value comes from M365_CLIENT_ID environment variable
     *
     * @readonly
     */
    readonly clientId?: string;
    /**
     * Secret string that the application uses when requesting a token. Only used in confidential client applications. Can be created in the Azure app registration portal. Default value comes from M365_CLIENT_SECRET environment variable
     *
     * @readonly
     */
    readonly clientSecret?: string;
    /**
     * The content of a PEM-encoded public/private key certificate.
     *
     * @readonly
     */
    readonly certificateContent?: string;
    /**
     * Login page for Teams to redirect to.  Default value comes from INITIATE_LOGIN_ENDPOINT environment variable.
     *
     * @readonly
     */
    readonly initiateLoginEndpoint?: string;
    /**
     * Application ID URI. Default value comes from M365_APPLICATION_ID_URI environment variable.
     */
    readonly applicationIdUri?: string;
}

/**
 * Defines method that injects authentication info to http requests
 */
export declare interface AuthProvider {
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     */
    AddAuthenticationInfo: (config: AxiosRequestConfig) => Promise<AxiosRequestConfig>;
}

export { AxiosInstance }

/**
 * Provider that handles Basic authentication
 */
export declare class BasicAuthProvider implements AuthProvider {
    private userName;
    private password;
    /**
     *
     * @param { string } userName - Username used in basic auth
     * @param { string } password - Password used in basic auth
     *
     * @throws {@link ErrorCode|InvalidParameter} - when username or password is empty.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(userName: string, password: string);
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header or auth property already exists in request configuration.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

/**
 * Provider that handles Bearer Token authentication
 */
export declare class BearerTokenAuthProvider implements AuthProvider {
    private getToken;
    /**
     * @param { () => Promise<string> } getToken - Function that returns the content of bearer token used in http request
     */
    constructor(getToken: () => Promise<string>);
    /**
     * Adds authentication info to http requests
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|AuthorizationInfoAlreadyExists} - when Authorization header already exists in request configuration.
     */
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

/**
 * Provider that handles Certificate authentication
 */
export declare class CertificateAuthProvider implements AuthProvider {
    private certOption;
    /**
     *
     * @param { SecureContextOptions } certOption - information about the cert used in http requests
     *
     * @throws {@link ErrorCode|InvalidParameter} - when cert option is empty.
     */
    constructor(certOption: SecureContextOptions);
    /**
     * Adds authentication info to http requests.
     *
     * @param { AxiosRequestConfig } config - Contains all the request information and can be updated to include extra authentication info.
     * Refer https://axios-http.com/docs/req_config for detailed document.
     *
     * @returns Updated axios request config.
     *
     * @throws {@link ErrorCode|InvalidParameter} - when custom httpsAgent in the request has duplicate properties with certOption provided in constructor.
     */
    AddAuthenticationInfo(config: AxiosRequestConfig): Promise<AxiosRequestConfig>;
}

/**
 * A {@link NotificationTarget} that represents a team channel.
 *
 * @remarks
 * It's recommended to get channels from {@link TeamsBotInstallation.channels()}.
 */
export declare class Channel implements NotificationTarget {
    /**
     * The parent {@link TeamsBotInstallation} where this channel is created from.
     */
    readonly parent: TeamsBotInstallation;
    /**
     * Detailed channel information.
     */
    readonly info: ChannelInfo;
    /**
     * Notification target type. For channel it's always "Channel".
     */
    readonly type: NotificationTargetType;
    /**
     * Constructor.
     *
     * @remarks
     * It's recommended to get channels from {@link TeamsBotInstallation.channels()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this channel is created from.
     * @param info - Detailed channel information.
     */
    constructor(parent: TeamsBotInstallation, info: ChannelInfo);
    /**
     * Send a plain text message.
     *
     * @param text - the plain text message.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendMessage(text: string): Promise<void>;
    /**
     * Send an adaptive card message.
     *
     * @param card - the adaptive card raw JSON.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendAdaptiveCard(card: unknown): Promise<void>;
    /**
     * @internal
     */
    private newConversation;
}

/**
 * A command bot for receiving commands and sending responses in Teams.
 *
 * @remarks
 * Ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
 */
export declare class CommandBot {
    private readonly adapter;
    private readonly middleware;
    /**
     * Creates a new instance of the `CommandBot`.
     *
     * @param adapter The bound `BotFrameworkAdapter`.
     * @param options - initialize options
     */
    constructor(adapter: BotFrameworkAdapter, options?: CommandOptions);
    /**
     * Registers a command into the command bot.
     *
     * @param command The command to registered.
     */
    registerCommand(command: TeamsFxBotCommandHandler): void;
    /**
     * Registers commands into the command bot.
     *
     * @param commands The command to registered.
     */
    registerCommands(commands: TeamsFxBotCommandHandler[]): void;
}

/**
 * Interface for a command message that can handled in a command handler.
 */
export declare interface CommandMessage {
    /**
     * Text of the message sent by the user.
     */
    text: string;
    /**
     * The capture groups that matched to the {@link TriggerPatterns} in a {@link TeamsFxBotCommandHandler} instance.
     */
    matches?: RegExpMatchArray;
}

/**
 * Options to initialize {@link CommandBot}.
 */
export declare interface CommandOptions {
    /**
     * The commands to registered with the command bot. Each command should implement the interface {@link TeamsFxBotCommandHandler} so that it can be correctly handled by this command bot.
     */
    commands?: TeamsFxBotCommandHandler[];
}

/**
 * Provide utilities for bot conversation, including:
 *   - handle command and response.
 *   - send notification to varies targets (e.g., member, group, channel).
 *
 * @example
 * For command and response, you can register your commands through the constructor, or use the `registerCommand` and `registerCommands` API to add commands later.
 *
 * ```typescript
 * // register through constructor
 * const conversationBot = new ConversationBot({
 *   command: {
 *     enabled: true,
 *     commands: [ new HelloWorldCommandHandler() ],
 *   },
 * });
 *
 * // register through `register*` API
 * conversationBot.command.registerCommand(new HelpCommandHandler());
 * ```
 *
 * For notification, you can enable notification at initialization, then send notifications at any time.
 *
 * ```typescript
 * // enable through constructor
 * const conversationBot = new ConversationBot({
 *   notification: {
 *     enabled: true,
 *   },
 * });
 *
 * // get all bot installations and send message
 * for (const target of await conversationBot.notification.installations()) {
 *   await target.sendMessage("Hello Notification");
 * }
 *
 * // alternative - send message to all members
 * for (const target of await conversationBot.notification.installations()) {
 *   for (const member of await target.members()) {
 *     await member.sendMessage("Hello Notification");
 *   }
 * }
 * ```
 *
 * @remarks
 * Set `adapter` in {@link ConversationOptions} to use your own bot adapter.
 *
 * For command and response, ensure each command should ONLY be registered with the command once, otherwise it'll cause unexpected behavior if you register the same command more than once.
 *
 * For notification, set `notification.storage` in {@link ConversationOptions} to use your own storage implementation.
 */
export declare class ConversationBot {
    /**
     * The bot adapter.
     */
    readonly adapter: BotFrameworkAdapter;
    /**
     * The entrypoint of command and response.
     */
    readonly command?: CommandBot;
    /**
     * The entrypoint of notification.
     */
    readonly notification?: NotificationBot;
    /**
     * Creates new instance of the `ConversationBot`.
     *
     * @remarks
     * It's recommended to create your own adapter and storage for production environment instead of the default one.
     *
     * @param options - initialize options
     */
    constructor(options: ConversationOptions);
    private createDefaultAdapter;
    /**
     * The request handler to integrate with web request.
     *
     * @param req - an Express or Restify style request object.
     * @param res - an Express or Restify style response object.
     * @param logic - the additional function to handle bot context.
     *
     * @example
     * For example, to use with Restify:
     * ``` typescript
     * // The default/empty behavior
     * server.post("api/messages", conversationBot.requestHandler);
     *
     * // Or, add your own logic
     * server.post("api/messages", async (req, res) => {
     *   await conversationBot.requestHandler(req, res, async (context) => {
     *     // your-own-context-logic
     *   });
     * });
     * ```
     */
    requestHandler(req: WebRequest, res: WebResponse, logic?: (context: TurnContext_2) => Promise<any>): Promise<void>;
}

/**
 * Options to initialize {@link ConversationBot}
 */
export declare interface ConversationOptions {
    /**
     * The bot adapter. If not provided, a default adapter will be created:
     * - with `adapterConfig` as constructor parameter.
     * - with a default error handler that logs error to console, sends trace activity, and sends error message to user.
     *
     * @remarks
     * If neither `adapter` nor `adapterConfig` is provided, will use BOT_ID and BOT_PASSWORD from environment variables.
     */
    adapter?: BotFrameworkAdapter;
    /**
     * If `adapter` is not provided, this `adapterConfig` will be passed to the new `BotFrameworkAdapter` when created internally.
     *
     * @remarks
     * If neither `adapter` nor `adapterConfig` is provided, will use BOT_ID and BOT_PASSWORD from environment variables.
     */
    adapterConfig?: {
        [key: string]: unknown;
    };
    /**
     * The command part.
     */
    command?: CommandOptions & {
        /**
         * Whether to enable command or not.
         */
        enabled?: boolean;
    };
    /**
     * The notification part.
     */
    notification?: NotificationOptions_2 & {
        /**
         * Whether to enable notification or not.
         */
        enabled?: boolean;
    };
}

/**
 * Initializes new Axios instance with specific auth provider
 *
 * @param apiEndpoint - Base url of the API
 * @param authProvider - Auth provider that injects authentication info to each request
 * @returns axios instance configured with specfic auth provider
 *
 * @example
 * ```typescript
 * const client = createApiClient("https://my-api-endpoint-base-url", new BasicAuthProvider("xxx","xxx"));
 * ```
 */
export declare function createApiClient(apiEndpoint: string, authProvider: AuthProvider): AxiosInstance;

/**
 * Get Microsoft graph client.
 *
 * @example
 * Get Microsoft graph client by TokenCredential
 * ```typescript
 * // Sso token example (Azure Function)
 * const ssoToken = "YOUR_TOKEN_STRING";
 * const options = {"AAD_APP_ID", "AAD_APP_SECRET"};
 * const credential = new OnBehalfOfAADUserCredential(ssoToken, options);
 * const graphClient = await createMicrosoftGraphClient(credential);
 * const profile = await graphClient.api("/me").get();
 *
 * // TeamsBotSsoPrompt example (Bot Application)
 * const requiredScopes = ["User.Read"];
 * const config: Configuration = {
 *    loginUrl: loginUrl,
 *    clientId: clientId,
 *    clientSecret: clientSecret,
 *    tenantId: tenantId
 * };
 * const prompt = new TeamsBotSsoPrompt(dialogId, {
 *    config: config
 *    scopes: '["User.Read"],
 * });
 * this.addDialog(prompt);
 *
 * const oboCredential = new OnBehalfOfAADUserCredential(
 *  getUserId(dialogContext),
 *  {
 *    clientId: "AAD_APP_ID",
 *    clientSecret: "AAD_APP_SECRET"
 *  });
 * try {
 *    const graphClient = await createMicrosoftGraphClient(credential);
 *    const profile = await graphClient.api("/me").get();
 * } catch (e) {
 *    dialogContext.beginDialog(dialogId);
 *    return Dialog.endOfTurn();
 * }
 * ```
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth.
 * @param scopes - The array of Microsoft Token scope of access. Default value is `[.default]`.
 *
 * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
 *
 * @returns Graph client with specified scopes.
 */
export declare function createMicrosoftGraphClient(teamsfx: TeamsFxConfiguration, scopes?: string | string[]): Client;

/**
 * Helper to create SecureContextOptions from PEM format cert
 *
 * @param { string | Buffer } cert - The cert chain in PEM format
 * @param { string | Buffer } key - The private key for the cert chain
 * @param { {passphrase?: string; ca?: string | Buffer} } options - Optional settings when create the cert options.
 *
 * @returns Instance of SecureContextOptions
 *
 * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
 *
 */
export declare function createPemCertOption(cert: string | Buffer, key: string | Buffer, options?: {
    passphrase?: string;
    ca?: string | Buffer;
}): SecureContextOptions;

/**
 * Helper to create SecureContextOptions from PFX format cert
 *
 * @param { string | Buffer } pfx - The content of .pfx file
 * @param { {passphrase?: string} } options - Optional settings when create the cert options.
 *
 * @returns Instance of SecureContextOptions
 *
 * @throws {@link ErrorCode|InvalidParameter} - when any parameter is empty
 *
 */
export declare function createPfxCertOption(pfx: string | Buffer, options?: {
    passphrase?: string;
}): SecureContextOptions;

/**
 * Error code to trace the error types.
 */
export declare enum ErrorCode {
    /**
     * Invalid parameter error.
     */
    InvalidParameter = "InvalidParameter",
    /**
     * Invalid configuration error.
     */
    InvalidConfiguration = "InvalidConfiguration",
    /**
     * Invalid certificate error.
     */
    InvalidCertificate = "InvalidCertificate",
    /**
     * Internal error.
     */
    InternalError = "InternalError",
    /**
     * Channel is not supported error.
     */
    ChannelNotSupported = "ChannelNotSupported",
    /**
     * Runtime is not supported error.
     */
    RuntimeNotSupported = "RuntimeNotSupported",
    /**
     * User failed to finish the AAD consent flow failed.
     */
    ConsentFailed = "ConsentFailed",
    /**
     * The user or administrator has not consented to use the application error.
     */
    UiRequiredError = "UiRequiredError",
    /**
     * Token is not within its valid time range error.
     */
    TokenExpiredError = "TokenExpiredError",
    /**
     * Call service (AAD or simple authentication server) failed.
     */
    ServiceError = "ServiceError",
    /**
     * Operation failed.
     */
    FailedOperation = "FailedOperation",
    /**
     * Invalid response error.
     */
    InvalidResponse = "InvalidResponse",
    /**
     * Identity type error.
     */
    IdentityTypeNotSupported = "IdentityTypeNotSupported",
    /**
     * Authentication info already exists error.
     */
    AuthorizationInfoAlreadyExists = "AuthorizationInfoAlreadyExists"
}

/**
 * Error class with code and message thrown by the SDK.
 */
export declare class ErrorWithCode extends Error {
    /**
     * Error code
     *
     * @readonly
     */
    code: string | undefined;
    /**
     * Constructor of ErrorWithCode.
     *
     * @param {string} message - error message.
     * @param {ErrorCode} code - error code.
     */
    constructor(message?: string, code?: ErrorCode);
}

/**
 * Get log level.
 *
 * @returns Log level
 */
export declare function getLogLevel(): LogLevel | undefined;

/**
 * Generate connection configuration consumed by tedious.
 *
 * @param {TeamsFx} teamsfx - Used to provide configuration and auth
 * @param { string? } databaseName - specify database name to override default one if there are multiple databases.
 *
 * @returns Connection configuration of tedious for the SQL.
 *
 * @throws {@link ErrorCode|InvalidConfiguration} when SQL config resource configuration is invalid.
 * @throws {@link ErrorCode|InternalError} when get user MSI token failed or MSI token is invalid.
 * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
 */
export declare function getTediousConnectionConfig(teamsfx: TeamsFx, databaseName?: string): Promise<ConnectionConfig>;

/**
 * Identity type to use in authentication.
 */
export declare enum IdentityType {
    /**
     * Represents the current user of Teams.
     */
    User = "User",
    /**
     * Represents the application itself.
     */
    App = "Application"
}

/**
 * Log function for customized logging.
 */
export declare type LogFunction = (level: LogLevel, message: string) => void;

/**
 * Interface for customized logger.
 */
export declare interface Logger {
    /**
     * Writes to error level logging or lower.
     */
    error(message: string): void;
    /**
     * Writes to warning level logging or lower.
     */
    warn(message: string): void;
    /**
     * Writes to info level logging or lower.
     */
    info(message: string): void;
    /**
     * Writes to verbose level logging.
     */
    verbose(message: string): void;
}

/**
 * Log level.
 */
export declare enum LogLevel {
    /**
     * Show verbose, information, warning and error message.
     */
    Verbose = 0,
    /**
     * Show information, warning and error message.
     */
    Info = 1,
    /**
     * Show warning and error message.
     */
    Warn = 2,
    /**
     * Show error message.
     */
    Error = 3
}

/**
 * A {@link NotificationTarget} that represents a team member.
 *
 * @remarks
 * It's recommended to get members from {@link TeamsBotInstallation.members()}.
 */
export declare class Member implements NotificationTarget {
    /**
     * The parent {@link TeamsBotInstallation} where this member is created from.
     */
    readonly parent: TeamsBotInstallation;
    /**
     * Detailed member account information.
     */
    readonly account: TeamsChannelAccount;
    /**
     * Notification target type. For member it's always "Person".
     */
    readonly type: NotificationTargetType;
    /**
     * Constructor.
     *
     * @remarks
     * It's recommended to get members from {@link TeamsBotInstallation.members()}, instead of using this constructor.
     *
     * @param parent - The parent {@link TeamsBotInstallation} where this member is created from.
     * @param account - Detailed member account information.
     */
    constructor(parent: TeamsBotInstallation, account: TeamsChannelAccount);
    /**
     * Send a plain text message.
     *
     * @param text - the plain text message.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendMessage(text: string): Promise<void>;
    /**
     * Send an adaptive card message.
     *
     * @param card - the adaptive card raw JSON.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendAdaptiveCard(card: unknown): Promise<void>;
    /**
     * @internal
     */
    private newConversation;
}

/**
 * Provides utility method to build bot message with cards that supported in Teams.
 */
export declare class MessageBuilder {
    /**
     * Build a bot message activity attached with adaptive card.
     *
     * @param cardTemplate The adaptive card template.
     * @param data card data used to render the template.
     * @returns A bot message activity attached with an adaptive card.
     *
     * @example
     * ```javascript
     * const cardTemplate = {
     *   type: "AdaptiveCard",
     *   body: [
     *     {
     *       "type": "TextBlock",
     *       "text": "${title}",
     *       "size": "Large"
     *     },
     *     {
     *       "type": "TextBlock",
     *       "text": "${description}"
     *     }],
     *     $schema: "http://adaptivecards.io/schemas/adaptive-card.json",
     *     version: "1.4"
     *  };
     *
     * type CardData = {
     *   title: string,
     *   description: string
     * };
     * const card = MessageBuilder.attachAdaptiveCard<CardData>(
     *   cardTemplate, {
     *   title: "sample card title",
     *   description: "sample card description"
     * });
     * ```
     */
    static attachAdaptiveCard<TData extends object>(cardTemplate: unknown, data: TData): Partial<Activity_2>;
    /**
     * Build a bot message activity attached with an adaptive card.
     *
     * @param card The adaptive card content.
     * @returns A bot message activity attached with an adaptive card.
     */
    static attachAdaptiveCardWithoutData(card: unknown): Partial<Activity_2>;
    /**
     * Build a bot message activity attached with an hero card.
     *
     * @param title The card title.
     * @param images Optional. The array of images to include on the card.
     * @param buttons Optional. The array of buttons to include on the card. Each `string` in the array
     *      is converted to an `imBack` button with a title and value set to the value of the string.
     * @param other Optional. Any additional properties to include on the card.
     *
     * @returns A bot message activity attached with a hero card.
     *
     * @example
     * ```javascript
     * const message = MessageBuilder.attachHeroCard(
     *      'sample title',
     *      ['https://example.com/sample.jpg'],
     *      ['action']
     * );
     * ```
     */
    static attachHeroCard(title: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<HeroCard>): Partial<Activity_2>;
    /**
     * Returns an attachment for a sign-in card.
     *
     * @param title The title for the card's sign-in button.
     * @param url The URL of the sign-in page to use.
     * @param text Optional. Additional text to include on the card.
     *
     * @returns A bot message activity attached with a sign-in card.
     *
     * @remarks
     * For channels that don't natively support sign-in cards, an alternative message is rendered.
     */
    static attachSigninCard(title: string, url: string, text?: string): Partial<Activity_2>;
    /**
     * Build a bot message activity attached with an Office 365 connector card.
     *
     * @param card A description of the Office 365 connector card.
     * @returns A bot message activity attached with an Office 365 connector card.
     */
    static attachO365ConnectorCard(card: O365ConnectorCard): Partial<Activity_2>;
    /**
     * Build a message activity attached with a receipt card.
     * @param card A description of the receipt card.
     * @returns A message activity attached with a receipt card.
     */
    static AttachReceiptCard(card: ReceiptCard): Partial<Activity_2>;
    /**
     *
     * @param title The card title.
     * @param images Optional. The array of images to include on the card.
     * @param buttons Optional. The array of buttons to include on the card. Each `string` in the array
     *      is converted to an `imBack` button with a title and value set to the value of the string.
     * @param other Optional. Any additional properties to include on the card.
     * @returns A message activity attached with a thumbnail card
     */
    static attachThumbnailCard(title: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<ThumbnailCard>): Partial<Activity_2>;
    /**
     * Add an attachement to a bot activity.
     * @param attachement The attachment object to attach.
     * @returns A message activity with an attachment.
     */
    static attachContent(attachement: Attachment): Partial<Activity_2>;
}

/**
 * Microsoft Graph auth provider for Teams Framework
 */
export declare class MsGraphAuthProvider implements AuthenticationProvider {
    private teamsfx;
    private scopes;
    /**
     * Constructor of MsGraphAuthProvider.
     *
     * @param {TeamsFx} teamsfx - Used to provide configuration and auth.
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     *
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     *
     * @returns An instance of MsGraphAuthProvider.
     */
    constructor(teamsfx: TeamsFxConfiguration, scopes?: string | string[]);
    /**
     * Get access token for Microsoft Graph API requests.
     *
     * @throws {@link ErrorCode|InternalError} when get access token failed due to empty token or unknown other problems.
     * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
     * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
     * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth or AAD server.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     *
     * @returns Access token from the credential.
     *
     */
    getAccessToken(): Promise<string>;
}

/**
 * Provide utilities to send notification to varies targets (e.g., member, group, channel).
 */
export declare class NotificationBot {
    private readonly conversationReferenceStore;
    private readonly adapter;
    /**
     * constructor of the notification bot.
     *
     * @remarks
     * To ensure accuracy, it's recommended to initialize before handling any message.
     *
     * @param adapter - the bound `BotFrameworkAdapter`
     * @param options - initialize options
     */
    constructor(adapter: BotFrameworkAdapter, options?: NotificationOptions_2);
    /**
     * Get all targets where the bot is installed.
     *
     * @remarks
     * The result is retrieving from the persisted storage.
     *
     * @returns - an array of {@link TeamsBotInstallation}.
     */
    installations(): Promise<TeamsBotInstallation[]>;
}

/**
 * Options to initialize {@link NotificationBot}.
 */
declare interface NotificationOptions_2 {
    /**
     * An optional storage to persist bot notification connections.
     *
     * @remarks
     * If `storage` is not provided, a default local file storage will be used,
     * which stores notification connections into:
     *   - ".notification.localstore.json" if running locally
     *   - "${process.env.TEMP}/.notification.localstore.json" if `process.env.RUNNING_ON_AZURE` is set to "1"
     *
     * It's recommended to use your own shared storage for production environment.
     */
    storage?: NotificationTargetStorage;
}
export { NotificationOptions_2 as NotificationOptions }

/**
 * Represent a notification target.
 */
export declare interface NotificationTarget {
    /**
     * The type of target, could be "Channel" or "Group" or "Person".
     */
    readonly type?: NotificationTargetType;
    /**
     * Send a plain text message.
     *
     * @param text - the plain text message.
     */
    sendMessage(text: string): Promise<void>;
    /**
     * Send an adaptive card message.
     *
     * @param card - the adaptive card raw JSON.
     */
    sendAdaptiveCard(card: unknown): Promise<void>;
}

/**
 * Interface for a storage provider that stores and retrieves notification target references.
 */
export declare interface NotificationTargetStorage {
    /**
     * Read one notification target by its key.
     *
     * @param key - the key of a notification target.
     *
     * @returns - the notification target. Or undefined if not found.
     */
    read(key: string): Promise<{
        [key: string]: unknown;
    } | undefined>;
    /**
     * List all stored notification targets.
     *
     * @returns - an array of notification target. Or an empty array if nothing is stored.
     */
    list(): Promise<{
        [key: string]: unknown;
    }[]>;
    /**
     * Write one notification target by its key.
     *
     * @param key - the key of a notification target.
     * @param object - the notification target.
     */
    write(key: string, object: {
        [key: string]: unknown;
    }): Promise<void>;
    /**
     * Delete one notification target by its key.
     *
     * @param key - the key of a notification target.
     */
    delete(key: string): Promise<void>;
}

/**
 * The target type where the notification will be sent to.
 *
 * @remarks
 * - "Channel" means to a team channel. (By default, notification to a team will be sent to its "General" channel.)
 * - "Group" means to a group chat.
 * - "Person" means to a personal chat.
 */
export declare type NotificationTargetType = "Channel" | "Group" | "Person";

/**
 * Represent on-behalf-of flow to get user identity, and it is designed to be used in server side.
 *
 * @example
 * ```typescript
 * const credential = new OnBehalfOfUserCredential(ssoToken);
 * ```
 *
 * @remarks
 * Can only be used in server side.
 */
export declare class OnBehalfOfUserCredential implements TokenCredential {
    private msalClient;
    private ssoToken;
    /**
     * Constructor of OnBehalfOfUserCredential
     *
     * @remarks
     * Only works in in server side.
     *
     * @param {string} ssoToken - User token provided by Teams SSO feature.
     * @param {AuthenticationConfiguration} config - The authentication configuration. Use environment variables if not provided.
     *
     * @throws {@link ErrorCode|InvalidConfiguration} when client id, client secret, certificate content, authority host or tenant id is not found in config.
     * @throws {@link ErrorCode|InternalError} when SSO token is not valid.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(ssoToken: string, config: AuthenticationConfiguration);
    /**
     * Get access token from credential.
     *
     * @example
     * ```typescript
     * await credential.getToken([]) // Get SSO token using empty string array
     * await credential.getToken("") // Get SSO token using empty string
     * await credential.getToken([".default"]) // Get Graph access token with default scope using string array
     * await credential.getToken(".default") // Get Graph access token with default scope using string
     * await credential.getToken(["User.Read"]) // Get Graph access token for single scope using string array
     * await credential.getToken("User.Read") // Get Graph access token for single scope using string
     * await credential.getToken(["User.Read", "Application.Read.All"]) // Get Graph access token for multiple scopes using string array
     * await credential.getToken("User.Read Application.Read.All") // Get Graph access token for multiple scopes using space-separated string
     * await credential.getToken("https://graph.microsoft.com/User.Read") // Get Graph access token with full resource URI
     * await credential.getToken(["https://outlook.office.com/Mail.Read"]) // Get Outlook access token
     * ```
     *
     * @param {string | string[]} scopes - The list of scopes for which the token will have access.
     * @param {GetTokenOptions} options - The options used to configure any requests this TokenCredential implementation might make.
     *
     * @throws {@link ErrorCode|InternalError} when failed to acquire access token on behalf of user with unknown error.
     * @throws {@link ErrorCode|TokenExpiredError} when SSO token has already expired.
     * @throws {@link ErrorCode|UiRequiredError} when need user consent to get access token.
     * @throws {@link ErrorCode|ServiceError} when failed to get access token from simple auth server.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns Access token with expected scopes.
     *
     * @remarks
     * If scopes is empty string or array, it returns SSO token.
     * If scopes is non-empty, it returns access token for target scope.
     */
    getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
    /**
     * Get basic user info from SSO token.
     *
     * @example
     * ```typescript
     * const currentUser = getUserInfo();
     * ```
     *
     * @throws {@link ErrorCode|InternalError} when SSO token is not valid.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns Basic user info with user displayName, objectId and preferredUserName.
     */
    getUserInfo(): UserInfo;
    private generateAuthServerError;
}

/**
 * Send an adaptive card message to a notification target.
 *
 * @param target - the notification target.
 * @param card - the adaptive card raw JSON.
 * @returns A `Promise` representing the asynchronous operation.
 */
export declare function sendAdaptiveCard(target: NotificationTarget, card: unknown): Promise<void>;

/**
 * Send a plain text message to a notification target.
 *
 * @param target - the notification target.
 * @param text - the plain text message.
 * @returns A `Promise` representing the asynchronous operation.
 */
export declare function sendMessage(target: NotificationTarget, text: string): Promise<void>;

/**
 * Set custom log function. Use the function if it's set. Priority is lower than setLogger.
 *
 * @param {LogFunction} logFunction - custom log function. If it's undefined, custom log function will be cleared.
 *
 * @example
 * ```typescript
 * setLogFunction((level: LogLevel, message: string) => {
 *   if (level === LogLevel.Error) {
 *     console.log(message);
 *   }
 * });
 * ```
 */
export declare function setLogFunction(logFunction?: LogFunction): void;

/**
 * Set custom logger. Use the output functions if it's set. Priority is higher than setLogFunction.
 *
 * @param {Logger} logger - custom logger. If it's undefined, custom logger will be cleared.
 *
 * @example
 * ```typescript
 * setLogger({
 *   verbose: console.debug,
 *   info: console.info,
 *   warn: console.warn,
 *   error: console.error,
 * });
 * ```
 */
export declare function setLogger(logger?: Logger): void;

/**
 * Update log level helper.
 *
 * @param { LogLevel } level - log level in configuration
 */
export declare function setLogLevel(level: LogLevel): void;

/**
 * A {@link NotificationTarget} that represents a bot installation. Teams Bot could be installed into
 * - Personal chat
 * - Group chat
 * - Team (by default the `General` channel)
 *
 * @remarks
 * It's recommended to get bot installations from {@link ConversationBot.installations()}.
 */
export declare class TeamsBotInstallation implements NotificationTarget {
    /**
     * The bound `BotFrameworkAdapter`.
     */
    readonly adapter: BotFrameworkAdapter;
    /**
     * The bound `ConversationReference`.
     */
    readonly conversationReference: Partial<ConversationReference>;
    /**
     * Notification target type.
     *
     * @remarks
     * - "Channel" means bot is installed into a team and notification will be sent to its "General" channel.
     * - "Group" means bot is installed into a group chat.
     * - "Person" means bot is installed into a personal scope and notification will be sent to personal chat.
     */
    readonly type?: NotificationTargetType;
    /**
     * Constructor
     *
     * @remarks
     * It's recommended to get bot installations from {@link ConversationBot.installations()}, instead of using this constructor.
     *
     * @param adapter - the bound `BotFrameworkAdapter`.
     * @param conversationReference - the bound `ConversationReference`.
     */
    constructor(adapter: BotFrameworkAdapter, conversationReference: Partial<ConversationReference>);
    /**
     * Send a plain text message.
     *
     * @param text - the plain text message.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendMessage(text: string): Promise<void>;
    /**
     * Send an adaptive card message.
     *
     * @param card - the adaptive card raw JSON.
     * @returns A `Promise` representing the asynchronous operation.
     */
    sendAdaptiveCard(card: unknown): Promise<void>;
    /**
     * Get channels from this bot installation.
     *
     * @returns an array of channels if bot is installed into a team, otherwise returns an empty array.
     */
    channels(): Promise<Channel[]>;
    /**
     * Get members from this bot installation.
     *
     * @returns an array of members from where the bot is installed.
     */
    members(): Promise<Member[]>;
}

/**
 * Creates a new prompt that leverage Teams Single Sign On (SSO) support for bot to automatically sign in user and
 * help receive oauth token, asks the user to consent if needed.
 *
 * @remarks
 * The prompt will attempt to retrieve the users current token of the desired scopes and store it in
 * the token store.
 *
 * User will be automatically signed in leveraging Teams support of Bot Single Sign On(SSO):
 * https://docs.microsoft.com/en-us/microsoftteams/platform/bots/how-to/authentication/auth-aad-sso-bots
 *
 * @example
 * When used with your bots `DialogSet` you can simply add a new instance of the prompt as a named
 * dialog using `DialogSet.add()`. You can then start the prompt from a waterfall step using either
 * `DialogContext.beginDialog()` or `DialogContext.prompt()`. The user will be prompted to sign in as
 * needed and their access token will be passed as an argument to the callers next waterfall step:
 *
 * ```JavaScript
 * const { ConversationState, MemoryStorage } = require('botbuilder');
 * const { DialogSet, WaterfallDialog } = require('botbuilder-dialogs');
 * const { TeamsBotSsoPrompt } = require('@microsoft/teamsfx');
 *
 * const convoState = new ConversationState(new MemoryStorage());
 * const dialogState = convoState.createProperty('dialogState');
 * const dialogs = new DialogSet(dialogState);
 *
 * dialogs.add(new TeamsBotSsoPrompt('TeamsBotSsoPrompt', {
 *    scopes: ["User.Read"],
 * }));
 *
 * dialogs.add(new WaterfallDialog('taskNeedingLogin', [
 *      async (step) => {
 *          return await step.beginDialog('TeamsBotSsoPrompt');
 *      },
 *      async (step) => {
 *          const token = step.result;
 *          if (token) {
 *
 *              // ... continue with task needing access token ...
 *
 *          } else {
 *              await step.context.sendActivity(`Sorry... We couldn't log you in. Try again later.`);
 *              return await step.endDialog();
 *          }
 *      }
 * ]));
 * ```
 */
export declare class TeamsBotSsoPrompt extends Dialog {
    private teamsfx;
    private settings;
    /**
     * Constructor of TeamsBotSsoPrompt.
     *
     * @param {TeamsFx} teamsfx - Used to provide configuration and auth
     * @param dialogId Unique ID of the dialog within its parent `DialogSet` or `ComponentDialog`.
     * @param settings Settings used to configure the prompt.
     *
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    constructor(teamsfx: TeamsFx, dialogId: string, settings: TeamsBotSsoPromptSettings);
    /**
     * Called when a prompt dialog is pushed onto the dialog stack and is being activated.
     * @remarks
     * If the task is successful, the result indicates whether the prompt is still
     * active after the turn has been processed by the prompt.
     *
     * @param dc The DialogContext for the current turn of the conversation.
     *
     * @throws {@link ErrorCode|InvalidParameter} when timeout property in teams bot sso prompt settings is not number or is not positive.
     * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     *
     * @returns A `Promise` representing the asynchronous operation.
     */
    beginDialog(dc: DialogContext): Promise<DialogTurnResult>;
    /**
     * Called when a prompt dialog is the active dialog and the user replied with a new activity.
     *
     * @remarks
     * If the task is successful, the result indicates whether the dialog is still
     * active after the turn has been processed by the dialog.
     * The prompt generally continues to receive the user's replies until it accepts the
     * user's reply as valid input for the prompt.
     *
     * @param dc The DialogContext for the current turn of the conversation.
     *
     * @returns A `Promise` representing the asynchronous operation.
     *
     * @throws {@link ErrorCode|ChannelNotSupported} when bot channel is not MS Teams.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is browser.
     */
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    private loadAndValidateConfig;
    /**
     * Ensure bot is running in MS Teams since TeamsBotSsoPrompt is only supported in MS Teams channel.
     * @param dc dialog context
     * @throws {@link ErrorCode|ChannelNotSupported} if bot channel is not MS Teams
     * @internal
     */
    private ensureMsTeamsChannel;
    /**
     * Send OAuthCard that tells Teams to obtain an authentication token for the bot application.
     * For details see https://docs.microsoft.com/en-us/microsoftteams/platform/bots/how-to/authentication/auth-aad-sso-bots.
     *
     * @internal
     */
    private sendOAuthCardAsync;
    /**
     * Get sign in resource.
     *
     * @throws {@link ErrorCode|InvalidConfiguration} if client id, tenant id or initiate login endpoint is not found in config.
     *
     * @internal
     */
    private getSignInResource;
    /**
     * @internal
     */
    private recognizeToken;
    /**
     * @internal
     */
    private getTokenExchangeInvokeResponse;
    /**
     * @internal
     */
    private isTeamsVerificationInvoke;
    /**
     * @internal
     */
    private isTokenExchangeRequestInvoke;
    /**
     * @internal
     */
    private isTokenExchangeRequest;
}

/**
 * Settings used to configure an TeamsBotSsoPrompt instance.
 */
export declare interface TeamsBotSsoPromptSettings {
    /**
     * The array of strings that declare the desired permissions and the resources requested.
     */
    scopes: string[];
    /**
     * (Optional) number of milliseconds the prompt will wait for the user to authenticate.
     * Defaults to a value `900,000` (15 minutes.)
     */
    timeout?: number;
    /**
     * (Optional) value indicating whether the TeamsBotSsoPrompt should end upon receiving an
     * invalid message.  Generally the TeamsBotSsoPrompt will end the auth flow when receives user
     * message not related to the auth flow. Setting the flag to false ignores the user's message instead.
     * Defaults to value `true`
     */
    endOnInvalidMessage?: boolean;
}

/**
 * Token response provided by Teams Bot SSO prompt
 */
export declare interface TeamsBotSsoPromptTokenResponse extends TokenResponse {
    /**
     * SSO token for user
     */
    ssoToken: string;
    /**
     * Expire time of SSO token
     */
    ssoTokenExpiration: string;
}

/**
 * A class providing credential and configuration.
 */
export declare class TeamsFx implements TeamsFxConfiguration {
    private configuration;
    private oboUserCredential?;
    private appCredential?;
    private identityType;
    /**
     * Constructor of TeamsFx
     *
     * @param {IdentityType} identityType - Choose user or app identity
     * @param customConfig - key/value pairs of customized configuration that overrides default ones.
     *
     * @throws {@link ErrorCode|IdentityTypeNotSupported} when setting app identity in browser.
     */
    constructor(identityType?: IdentityType, customConfig?: Record<string, string>);
    /**
     * Identity type set by user.
     *
     * @returns identity type.
     */
    getIdentityType(): IdentityType;
    /**
     * Credential instance according to identity type choice.
     *
     * @remarks If user identity is chose, will return {@link TeamsUserCredential}
     * in browser environment and {@link OnBehalfOfUserCredential} in NodeJS. If app
     * identity is chose, will return {@link AppCredential}.
     *
     * @returns instance implements TokenCredential interface.
     */
    getCredential(): TokenCredential;
    /**
     * Get user information.
     * @returns UserInfo object.
     */
    getUserInfo(): Promise<UserInfo>;
    /**
     * Popup login page to get user's access token with specific scopes.
     *
     * @remarks
     * Only works in Teams client APP. User will be redirected to the authorization page to login and consent.
     *
     * @example
     * ```typescript
     * await teamsfx.login(["https://graph.microsoft.com/User.Read"]); // single scope using string array
     * await teamsfx.login("https://graph.microsoft.com/User.Read"); // single scopes using string
     * await teamsfx.login(["https://graph.microsoft.com/User.Read", "Calendars.Read"]); // multiple scopes using string array
     * await teamsfx.login("https://graph.microsoft.com/User.Read Calendars.Read"); // multiple scopes using string
     * ```
     * @param scopes - The list of scopes for which the token will have access, before that, we will request user to consent.
     *
     * @throws {@link ErrorCode|InternalError} when failed to login with unknown error.
     * @throws {@link ErrorCode|ConsentFailed} when user canceled or failed to consent.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    login(scopes: string | string[]): Promise<void>;
    /**
     * Set SSO token when using user identity in NodeJS.
     * @param {string} ssoToken - used for on behalf of user flow.
     * @returns self instance.
     */
    setSsoToken(ssoToken: string): TeamsFx;
    /**
     * Usually used by service plugins to retrieve specific config
     * @param {string} key - configuration key.
     * @returns value in configuration.
     */
    getConfig(key: string): string;
    /**
     * Check the value of specific key.
     * @param {string} key - configuration key.
     * @returns true if corresponding value is not empty string.
     */
    hasConfig(key: string): boolean;
    /**
     * Get all configurations.
     * @returns key value mappings.
     */
    getConfigs(): Record<string, string>;
    /**
     * Load configuration from environment variables.
     */
    private loadFromEnv;
}

/**
 * Interface for a command handler that can process command to a TeamsFx bot and return a response.
 */
export declare interface TeamsFxBotCommandHandler {
    /**
     * The string or regular expression patterns that can trigger this handler.
     */
    triggerPatterns: TriggerPatterns;
    /**
     * Handles a bot command received activity.
     *
     * @param context The bot context.
     * @param message The command message the user types from Teams.
     * @returns A `Promise` representing an activity or text to send as the command response.
     * Or no return value if developers want to send the response activity by themselves in this method.
     */
    handleCommandReceived(context: TurnContext, message: CommandMessage): Promise<string | Partial<Activity> | void>;
}

/**
 * TeamsFx interface that provides credential and configuration.
 */
declare interface TeamsFxConfiguration {
    /**
     * Identity type set by user.
     *
     * @returns identity type.
     */
    getIdentityType(): IdentityType;
    /**
     * Credential instance according to identity type choice.
     *
     * @remarks If user identity is chose, will return {@link TeamsUserCredential}
     * in browser environment and {@link OnBehalfOfUserCredential} in NodeJS. If app
     * identity is chose, will return {@link AppCredential}.
     *
     * @returns instance implements TokenCredential interface.
     */
    getCredential(): TokenCredential;
    /**
     * Get user information.
     * @returns UserInfo object.
     */
    getUserInfo(): Promise<UserInfo>;
    /**
     * Popup login page to get user's access token with specific scopes.
     *
     * @remarks
     * Only works in Teams client APP. User will be redirected to the authorization page to login and consent.
     *
     * @example
     * ```typescript
     * await teamsfx.login(["https://graph.microsoft.com/User.Read"]); // single scope using string array
     * await teamsfx.login("https://graph.microsoft.com/User.Read"); // single scopes using string
     * await teamsfx.login(["https://graph.microsoft.com/User.Read", "Calendars.Read"]); // multiple scopes using string array
     * await teamsfx.login("https://graph.microsoft.com/User.Read Calendars.Read"); // multiple scopes using string
     * ```
     * @param scopes - The list of scopes for which the token will have access, before that, we will request user to consent.
     *
     * @throws {@link ErrorCode|InternalError} when failed to login with unknown error.
     * @throws {@link ErrorCode|ConsentFailed} when user canceled or failed to consent.
     * @throws {@link ErrorCode|InvalidParameter} when scopes is not a valid string or string array.
     * @throws {@link ErrorCode|RuntimeNotSupported} when runtime is nodeJS.
     */
    login(scopes: string | string[]): Promise<void>;
    /**
     * Set SSO token when using user identity in NodeJS.
     * @param {string} ssoToken - used for on behalf of user flow.
     * @returns self instance.
     */
    setSsoToken(ssoToken: string): TeamsFxConfiguration;
    /**
     * Usually used by service plugins to retrieve specific config
     * @param {string} key - configuration key.
     * @returns value in configuration.
     */
    getConfig(key: string): string;
    /**
     * Check the value of specific key.
     * @param {string} key - configuration key.
     * @returns true if corresponding value is not empty string.
     */
    hasConfig(key: string): boolean;
    /**
     * Get all configurations.
     * @returns key value mappings.
     */
    getConfigs(): Record<string, string>;
}

/**
 * Represent Teams current user's identity, and it is used within Teams client applications.
 *
 * @remarks
 * Can only be used within Teams.
 */
export declare class TeamsUserCredential implements TokenCredential {
    /**
     * Constructor of TeamsUserCredential.
     * @remarks
     * Can only be used within Teams.
     */
    constructor(authConfig: AuthenticationConfiguration);
    /**
     * Popup login page to get user's access token with specific scopes.
     * @remarks
     * Can only be used within Teams.
     */
    login(scopes: string | string[]): Promise<void>;
    /**
     * Get access token from credential.
     * @remarks
     * Can only be used within Teams.
     */
    getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
    /**
     * Get basic user info from SSO token
     * @remarks
     * Can only be used within Teams.
     */
    getUserInfo(): Promise<UserInfo>;
}

/**
 * The trigger pattern used to trigger a {@link TeamsFxBotCommandHandler} instance.
 */
export declare type TriggerPatterns = string | RegExp | (string | RegExp)[];

/**
 * UserInfo with user displayName, objectId and preferredUserName.
 */
export declare interface UserInfo {
    /**
     * User Display Name.
     *
     * @readonly
     */
    displayName: string;
    /**
     * User unique reference within the Azure Active Directory domain.
     *
     * @readonly
     */
    objectId: string;
    /**
     * Usually be the email address.
     *
     * @readonly
     */
    preferredUserName: string;
}

export { }
